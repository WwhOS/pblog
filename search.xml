<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode算法：数组]]></title>
    <url>%2Fblog%2FLeetCode-%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[最新内容快捷入口：有效的山脉数组 本文内容摘选自LeetCode-数组 所谓数组，是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便，把具有相同类型的若干元素按无序的形式组织起来的一种形式。 由简入难，我会从不同难度的数组算法题中挑选一些有代表性的进行解答。 简单1 两数之和 该题是算法题的第一道题，在之前的文章中解答过，这里不在重复解答。见LeetCode-算法题。 26 删除排序数组中的重复项 该题在之前的文章中解答过，见LeetCode-算法题。该题首次提到了原地算法和双指针法，值得看一下。 118 杨辉三角 作者：LeetCode链接：地址来源：力扣（LeetCode） 问题描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。 示例： 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 我的解答经过之前几十道算法题的洗礼，我在解答这道题时并没有花费什么功夫，思路也很简单，明白了每行的每个元素怎么求值题就解了。元素求值有两种方式： 每行的第一个和最后一个元素值恒为1 每对相邻的元素值的和是下一行对应元素的值。 Java语言实现。 123456789101112131415161718class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; rowList = new ArrayList&lt;&gt;(numRows); for (int row = 0; row &lt; numRows; row++) &#123; List&lt;Integer&gt; colList = new ArrayList&lt;&gt;(row + 1); rowList.add(colList); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; colList.add(1); &#125; else &#123; List&lt;Integer&gt; lastRowList = rowList.get(row - 1); colList.add(lastRowList.get(col - 1) + lastRowList.get(col)); &#125; &#125; &#125; return rowList; &#125;&#125; Kotlin语言实现，思路同上面的Java实现。 1234567891011121314151617181920/* 执行用时 : 248 ms, 在所有 Kotlin 提交中击败了 72.22% 的用户 内存消耗 : 32.1 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution &#123; fun generate(numRows: Int): List&lt;List&lt;Int&gt;&gt; &#123; val list = mutableListOf&lt;MutableList&lt;Int&gt;&gt;() for (row in 0 until numRows) &#123; list.add(mutableListOf()) for (col in 0..row) &#123; if (col == 0 || col == row) &#123; list[row].add(1) &#125; else &#123; list[row].add(list[row-1][col-1] + list[row-1][col]) &#125; &#125; &#125; return list &#125;&#125; 官方解答作者：LeetCode链接：地址来源：力扣（LeetCode） 方法：动态规划 实现思路和我的思路一致，这里不再累述，只贴出代码实现。但还是建议看下原文链接，有动态演示，很方便理解。虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;List&lt;Integer&gt;&gt;(); // First base case; if user requests zero rows, they get zero rows. if (numRows == 0) &#123; return triangle; &#125; // Second base case; first row is always [1]. triangle.add(new ArrayList&lt;&gt;()); triangle.get(0).add(1); for (int rowNum = 1; rowNum &lt; numRows; rowNum++) &#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); List&lt;Integer&gt; prevRow = triangle.get(rowNum-1); // The first row element is always 1. row.add(1); // Each triangle element (other than the first and last of each row) // is equal to the sum of the elements above-and-to-the-left and // above-and-to-the-right. for (int j = 1; j &lt; rowNum; j++) &#123; row.add(prevRow.get(j-1) + prevRow.get(j)); &#125; // The last row element is always 1. row.add(1); triangle.add(row); &#125; return triangle; &#125;&#125; 169 求众数 作者：LeetCode链接：地址来源：力扣（LeetCode） 问题描述给定一个大小为n的数组，找到其中的众数。众数是指在数组中出现次数大于n/2的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 我的解答这道题正确解答很简单，解法也有很多种，但是想解的好却不容易。短时间内我也只写出了下面两种解法，虽然想到了分治法也能求解，但是没有用代码实现。建议看看下面的官方题解，一些解法真的巧妙！ 哈希表思路很简单，用一个循环遍历数组，将元素和元素出现的次数存入到哈希表，最后迭代哈希表得到众数。 12345678910111213141516171819class Solution &#123; /* 执行用时 : 456 ms, 在所有 Kotlin 提交中击败了 48.15% 的用户 内存消耗 : 50.2 MB, 在所有 Kotlin 提交中击败了 75.00% 的用户 */ fun majorityElement(nums: IntArray): Int &#123; val map = mutableMapOf&lt;Int, Int&gt;() for (num in nums) &#123; map[num] = (map[num] ?: 0) + 1 &#125; val tmp = nums.size.div(2) map.forEach &#123; (key, value) -&gt; if (value &gt; tmp) &#123; return key &#125; &#125; throw Error() &#125;&#125; 暴力法双重循环求解，外层循环控制元素，内层循环计算元素出现的次数，当出现满足众数条件时返回元素。由于该解法使用双重循环，导致执行用时过高，远超出我预期。 12345678910111213141516171819202122class Solution &#123; /* 执行用时 : 2604 ms, 在所有 Kotlin 提交中击败了 7.41% 的用户 内存消耗 : 50.3 MB, 在所有 Kotlin 提交中击败了 75.00% 的用户 */ fun majorityElement(nums: IntArray): Int &#123; val majorityCount = nums.size.div(2) var count: Int for (num in nums) &#123; count = 0 for (num2 in nums) &#123; if (num2 == num) &#123; count++ &#125; &#125; if (count &gt; majorityCount) &#123; return num &#125; &#125; throw Error() &#125;&#125; 官方题解作者：LeetCode链接：地址来源：力扣（LeetCode） 这里过滤了一些常规解答，只列出了比较巧妙的解法，对其他解法感兴趣的同学可以点击地址看下。 排序所有解法中代码行数最少，只有两行： 123456class Solution &#123; public int majorityElement(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125;&#125; 思路：满足众数条件的元素，出现的次数超出了数组总长度的一半，那么在为数组排序后，数组最中间的元素肯定就是众数！ [3,2,3] 排序后：[2,3,3]，最中间的元素是：3[2,2,1,1,1,2,2] 排序后：[1,1,1,2,2,2,2]，最中间的元素是：2 随机化思路：由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它的值是否是众数，如果是就返回，否则继续随机挑选。 12345678910111213141516171819202122232425class Solution &#123; private int randRange(Random rand, int min, int max) &#123; return rand.nextInt(max - min) + min; &#125; // 统计指定数字在数组中出现的次数 private int countOccurences(int[] nums, int num) &#123; int count = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == num) &#123; count++; &#125; &#125; return count; &#125; public int majorityElement(int[] nums) &#123; Random rand = new Random(); int majorityCount = nums.length/2; while (true) &#123; int candidate = nums[randRange(rand, 0, nums.length)]; if (countOccurences(nums, candidate) &gt; majorityCount) &#123; return candidate; &#125; &#125; &#125;&#125; Boyer-Moore 投票算法该算法的思路及其巧妙，在看完时对作者竖然起敬，然后发现这不是“开心消消乐”吗？！ 思路 如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。 定义一个候选众数 candidate，再维护一个计数器 count。遇到和 candidate 相同的数字， count 加一，否则 count 减一。当 count 等于0时，忽略钱买额数字，将候选众数 candidate 改为下一个数字，计数器 count 重置为0。这样最后剩下的候选众数 candidate 就是要求的众数。 来看两个示例（竖线用来划分每次计数器归零的情况）。[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7][7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5] 12345678910111213class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 0; Integer candidate = null; for (int num : nums) &#123; if (count == 0) &#123; candidate = num; &#125; count += (num == candidate) ? 1 : -1; &#125; return candidate; &#125;&#125; 448 找到所有数组中消失的数字 作者：LeetCode链接：地址来源：力扣（LeetCode） 问题描述给定一个范围在1 ≤ a[i] ≤ n（n=数组大小）的整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内 示例: 输入:[4,3,2,7,8,2,3,1]输出:[5,6] 我的解答该题还是有一定的难度的，尤其是要求不使用额外空间且时间复杂度为O(n)的情况下完成这个任务。 思索来思索去，并没有想到优雅些的解决办法，所以使用暴力法进行求解，结果提交后没有通过。又审了几遍题，发现是我忽略了一点：n=数组大小，找出[1, n]范围之间没有出现在数组中的数字，惭愧的很。 修改后再次提交，顺利通过，但执行结果惨不忍睹。再来！ 使用动态规划求解，执行结果有些超出预期，但代码实现可读性有些差。再来！ 修改后的动态规划代码实现看起来就舒服了一些！收工，看下官方题解。 暴力法12345678910111213141516/** * 解答错误 */class Solution &#123; fun findDisappearedNumbers(nums: IntArray): List&lt;Int&gt; &#123; val disNums = arrayListOf&lt;Int&gt;() if (nums.size &lt;= 1) return disNums nums.sort() for (el in nums[0]..nums[nums.lastIndex]) &#123; if (!nums.contains(el)) &#123; disNums.add(el) &#125; &#125; return disNums &#125;&#125; 修改后的暴力法123456789101112131415/** * 执行用时 : 2232 ms, 在所有 Kotlin 提交中击败了 25.00% 的用户 * 内存消耗 : 52.4 MB, 在所有 Kotlin 提交中击败了 50.00% 的用户 */class Solution2 &#123; fun findDisappearedNumbers(nums: IntArray): List&lt;Int&gt; &#123; val disNums = arrayListOf&lt;Int&gt;() for (el in 1..nums.size) &#123; if (!nums.contains(el)) &#123; disNums.add(el) &#125; &#125; return disNums &#125;&#125; 动态规划123456789101112131415161718192021222324/** * 执行用时 : 472 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户 * 内存消耗 : 50.8 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution &#123; fun findDisappearedNumbers(nums: IntArray): List&lt;Int&gt; &#123; val disNums = arrayListOf&lt;Int&gt;() nums.sort() nums.forEachIndexed &#123; index, el -&gt; val tmp = if (index &gt; 0) nums[index-1]+1 else 1 if (el &gt; tmp) &#123; for (diff in tmp until el) &#123; disNums.add(diff) &#125; &#125; if (index == nums.lastIndex &amp;&amp; el &lt; nums.size) &#123; for (diff in el+1..nums.size) &#123; disNums.add(diff) &#125; &#125; &#125; return disNums &#125;&#125; 优化过的动态规划1234567891011121314151617181920212223242526272829303132/** * 执行用时 : 480 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户 * 内存消耗 : 51 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution &#123; fun findDisappearedNumbers(nums: IntArray): List&lt;Int&gt; &#123; val disNums = arrayListOf&lt;Int&gt;() if (nums.isEmpty()) return disNums nums.sort() fun addByDiff(from: Int, untilTo: Int) &#123; for (el in from until untilTo) &#123; disNums.add(el) &#125; &#125; nums.forEachIndexed &#123; index, el -&gt; if (index == 0) &#123; if (el &gt; 1) &#123; addByDiff(1, el) &#125; &#125; else if (el &gt; nums[index-1]+1) &#123; addByDiff(nums[index-1]+1, el) &#125; &#125; if (nums[nums.lastIndex] &lt; nums.size) &#123; for (el in nums[nums.lastIndex]+1..nums.size) &#123; disNums.add(el) &#125; &#125; return disNums &#125;&#125; 精选题解作者：haydenmiao链接：地址来源：力扣（LeetCode） 思路： 将数组元素对应为索引的位置加n 遍历加n后的数组，若数组元素值小于等于n，则说明数组下标值不存在，即消失的数字 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; if(nums.empty()) return nums; for(int i=0;i&lt;nums.size();i++) &#123; int index=(nums[i]-1)%nums.size(); nums[index]+=nums.size(); &#125; for(int i=0;i&lt;nums.size();i++) &#123; if(nums[i]&lt;=nums.size()) res.push_back(i+1); &#125; return res; &#125;&#125;; 作者没有使用Java和Kotlin语言实现该解题思路，我使用Kotlin语言进行了实现。 12345678910111213141516171819/** * 执行用时 : 392 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户 * 内存消耗 : 49.6 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution4 &#123; fun findDisappearedNumbers(nums: IntArray): List&lt;Int&gt; &#123; val disNums = arrayListOf&lt;Int&gt;() if (nums.isEmpty()) return disNums for (el in nums) &#123; nums[(el-1) % nums.size] += nums.size &#125; nums.forEachIndexed &#123; index, el -&gt; if (el &lt;= nums.size) &#123; disNums.add(index+1) &#125; &#125; return disNums &#125;&#125; 566 重塑矩阵 作者：LeetCode来源：力扣（LeetCode）链接：地址 在MATLAB中，有一个非常有用的函数reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 输入:nums = [[1,2],[3,4]]r = 1, c = 4输出:[[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 输入:nums = [[1,2],[3,4]]r = 2, c = 4输出:[[1,2],[3,4]]解释:没有办法将 2 2 矩阵转化为 2 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。给定的 r 和 c 都是正数。 我的解答解题思路： 先判断原始矩阵和转换后的新矩阵的元素个数是否相等。 若相等，说明可以转换；若不相等，说明不能转换。 使用“双指针”：rowCount和colCount代表原始矩阵的行和列，依次取出原始矩阵中的元素存放到新矩阵中即可。 123456789101112131415161718192021222324252627/** * 执行用时 : 328 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户 * 内存消耗 : 44.9 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution &#123; fun matrixReshape(nums: Array&lt;IntArray&gt;, r: Int, c: Int): Array&lt;IntArray&gt; &#123; if (r * c != nums.size * nums[0].size) &#123; return nums &#125; val result = mutableListOf&lt;IntArray&gt;() var rowCount = 0 var colCount = 0 for (_r in 0 until r) &#123; val rowArray = mutableListOf&lt;Int&gt;() for (_c in 0 until c) &#123; rowArray.add(nums[rowCount][colCount]) colCount++ if (colCount &gt; nums[rowCount].lastIndex) &#123; rowCount++ colCount = 0 &#125; &#125; result.add(rowArray.toIntArray()) &#125; return result.toTypedArray() &#125;&#125; 官方题解作者：LeetCode链接：题解来源：力扣（LeetCode） 看了官方题解后，发现我的解答法是“不用额外空间”，不过官方给出的题解思路很相似，复杂度上也都相同，该题并没有特别“巧妙”的解法。 使用队列 [通过]最简单的方法是通过以行方式读取元素来提取给定矩阵的所有元素。在此实现中，我们使用队列来放置提取的元素。然后，我们可以取出以串行顺序形成的队列元素，并再次按行逐行排列所得到的所需矩阵中的元素。如果原始矩阵中的元素数量不等于所得矩阵中的元素数量，则不可能形成所得矩阵。 1234567891011121314151617181920public class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int[][] res = new int[r][c]; if (nums.length == 0 || r * c != nums.length * nums[0].length) return nums; int count = 0; Queue &lt; Integer &gt; queue = new LinkedList &lt; &gt; (); for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums[0].length; j++) &#123; queue.add(nums[i][j]); &#125; &#125; for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; res[i][j] = queue.remove(); &#125; &#125; return res; &#125;&#125; 不用额外空间 [通过]我们不必像在暴力方法中那样不必要地使用队列，而是可以在逐行顺序迭代给定矩阵的同时，直接将数字放在结果矩阵中。在将数字放入结果数组时，我们固定一个特定的行，并继续增加列数，直到我们到达cc指示的所需列的末尾。此时，我们通过递增来更新行索引，并将列索引重置为从0开始。因此，我们可以节省队列消耗的空间，以便存储只需要复制到新数组中的数据。 12345678910111213141516171819public class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int[][] res = new int[r][c]; if (nums.length == 0 || r * c != nums.length * nums[0].length) return nums; int rows = 0, cols = 0; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums[0].length; j++) &#123; res[rows][cols] = nums[i][j]; cols++; if (cols == c) &#123; rows++; cols = 0; &#125; &#125; &#125; return res; &#125;&#125; 除法和取模 [通过]在上一种方法中，我们需要跟踪我们何时到达结果矩阵的列的末尾，并且需要通过每次检查当前索引来更新当前行和列号以放置提取的元素。我们可以利用数学来帮助解决，而不是在每一步都进行限制性检查。 这种方法背后的想法如下。 你知道二维数组是如何存储在主存中的（本质上是一维）吗？它仅在内部表示为一维阵列。元素 nums[i][j]nums 数组通过使用以下形式的索引以一维数组的形式表示：$ nums [n * i + j]，其中 m 是给定矩阵中的列数。以相反的顺序查看相同的内容，同时将元素放在结果矩阵中的元素中，我们可以使用 count 变量，该变量对于遍历的每个元素都会递增，就像我们将元素放在一维中一样结果数组。但是，要将 count 转换回列数为转换回列数为 c 的二维矩阵索引，我们可以获得 res [count / c] [count \％c] 的索引，其中 count / c 是行号和是行号和 count \％c $是列数字。因此，我们可以节省每一步所需的额外检查。 123456789101112131415public class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int[][] res = new int[r][c]; if (nums.length == 0 || r * c != nums.length * nums[0].length) return nums; int count = 0; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums[0].length; j++) &#123; res[count / c][count % c] = nums[i][j]; count++; &#125; &#125; return res; &#125;&#125; 661 图片平滑器 作者：LeetCode来源：力扣（LeetCode）链接：地址 包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。 示例 1: 输入:[[1,1,1],[1,0,1],[1,1,1]]输出:[[0, 0, 0],[0, 0, 0],[0, 0, 0]]解释:对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0 注意: 给定矩阵中的整数范围为 [0, 255]。 矩阵的长和宽的范围均为 [1, 150]。 我的解答 思路：“双重嵌套”+“补位” 创建一个新的矩阵，双重嵌套遍历矩阵。 通过“补位”使原矩阵中每个单位周围有8个单位格。 在双重嵌套最内部计算单位的平均值，通过单元在矩阵中的坐标判断是否是“补位”单元，来计算平均值。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 执行用时 : 392 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户 * 内存消耗 : 38.3 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution &#123; fun imageSmoother(M: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; &#123; if (M.isEmpty() || M[0].isEmpty()) return M fun getEl(row: Int, col: Int): Int &#123; return when &#123; row &lt; 0 || row &gt;= M.size -&gt; -1 col &lt; 0 || col &gt;= M[0].size -&gt; -1 else -&gt; M[row][col] &#125; &#125; var elCount = 0 var elSum = 0 fun handle(el: Int) &#123; if (el &gt;= 0) &#123; elCount++ elSum += el &#125; &#125; val resetArray = arrayOfNulls&lt;IntArray&gt;(M.size) for (row in M.indices) &#123; resetArray[row] = IntArray(M[0].size) &#123; col -&gt; elCount = 0 elSum = 0 handle(getEl(row - 1, col - 1)) handle(getEl(row - 1, col)) handle(getEl(row - 1, col + 1)) handle(getEl(row, col - 1)) handle(getEl(row, col)) handle(getEl(row, col + 1)) handle(getEl(row + 1, col - 1)) handle(getEl(row + 1, col)) handle(getEl(row + 1, col + 1)) elSum / elCount &#125; &#125; return resetArray as Array&lt;IntArray&gt; &#125;&#125; 精选题解见我的解答，得瑟一波～ 我在看了部分题解后，并没有发现特别好的解题思路，有些解法思路复杂、实现繁琐，并没有我的解法简洁，所以毛（hoz）遂（yan）自（wu）荐（chi）把自己的解法贴了出来。貌似，“矩阵”类的算法题并没有特别好的解法？ 再毛（chou）遂（bu）自（yao）荐（lian）一次，我把我的题解也发布到LeetCode上了，点这里查看，欢迎点赞和交流！ 941 有效的山脉数组 作者：LeetCode来源：力扣（LeetCode）链接：地址 给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[B.length - 1] 示例 1： 输入：[2,1]输出：false 示例 2： 输入：[3,5,5]输出：false 示例 3： 输入：[0,3,2,1]输出：true 提示： 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 我的解答思路：只需要一次循环 要解答该题，首先要找到”山脉”最高点maxElIndex。 在找到maxElIndex前，后面的元素小于等于前面的元素，说明不是有效的”山脉数组”。 在找到maxElIndex后，后面的元素大于等于前面的元素，说明不是有效的”山脉数组”。 排除上面两种情况后，最后再检查一下找到的最高点不能是第一个和最后一个元素。 12345678910111213141516171819202122232425262728/** * 执行用时 : 288 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户 * 内存消耗 : 38.8 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution &#123; fun validMountainArray(A: IntArray): Boolean &#123; var maxElIndex: Int? = null A.forEachIndexed &#123; index, el -&gt; when &#123; // 找到"山脉"最高点 maxElIndex == null &amp;&amp; index-1 &gt;= 0 &amp;&amp; index+1 &lt; A.size &amp;&amp; el &gt; A[index-1] &amp;&amp; el &gt; A[index+1] -&gt; &#123; maxElIndex = el maxElIndex = index &#125; // 在找到最高点前，后面的元素小于等于前面的元素，说明不是有效的"山脉数组" maxElIndex == null &amp;&amp; index-1 &gt;= 0 &amp;&amp; el &lt;= A[index-1] -&gt; &#123; return false &#125; // 在找到最高点后，后面的元素大于等于前面的元素，说明不是有效的"山脉数组" maxElIndex != null &amp;&amp; index-1 &gt;= 0 &amp;&amp; el &gt;= A[index-1] -&gt; &#123; return false &#125; &#125; &#125; // 最后，找到的最高点不能是第一个和最后一个元素 return maxElIndex != null &amp;&amp; maxElIndex != 0 &amp;&amp; maxElIndex != A.lastIndex &#125;&#125; 官方题解作者：LeetCode链接：地址来源：力扣（LeetCode） 线性扫描我们从数组的最左侧开始扫描，直到找到第一个不满足 A[i] &lt; A[i + 1] 的 i，那么 i 就是这个数组的最高点。如果 i = 0 或者不存在这样的 i（即整个数组都是单调递增的），那么就返回 false。否则从 i 开始继续扫描，判断接下来的的位置 j 是否都满足 A[j] &gt; A[j + 1]，若都满足就返回 true，否则返回 false。 12345678910111213141516class Solution &#123; public boolean validMountainArray(int[] A) &#123; int N = A.length; int i = 0; // walk up while (i+1 &lt; N &amp;&amp; A[i] &lt; A[i+1]) i++; // peak can't be first or last if (i == 0 || i == N-1) return false; // walk down while (i+1 &lt; N &amp;&amp; A[i] &gt; A[i+1]) i++; return i == N-1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-算法题]]></title>
    <url>%2Fblog%2FLeetCode-%E7%AE%97%E6%B3%95%E9%A2%98-%E5%89%8D66-%E7%AE%80%E5%8D%95%2F</url>
    <content type="text"><![CDATA[解题过程中发现安照算法难度和顺序解题学习效率有些低，遂改成了使用标签解题。之后解答算法会以算法类型为文章名称进行更新。建议按照标签分类学习，能更好的掌握一种算法类型，学习具有针对性和系统性。 LeetCode官网地址 LeetCode简单算法题：1～205 为方便查看本文最近更新的内容，特地加了便捷入口，点击查看：加一。 1 两数之和 记得面试时是被问到过这个题的，但当时被前面的面试题搞的有些发懵，理解错了“不能重复利用这个数组中同样的元素”这句话的含义，实在惭愧，再看到这道题时一时感慨万千。 问题描述给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的那 两个整数 ，并返回他们的 数组下标 。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答过程首先分析下问题： 参数：数组 nums 是一个无序整数数组，元素可重复；target 是一个整数 需求：target是数组中两个元素的和；数组中必有也只有两个元素能满足条件；不能重复利用两个数组中同样的元素 结果：满足需求的两个元素的下标 疑问：未能理解 不能重复利用两个数组中同样的元素 这个要求 思路：两个循环嵌套找出所需元素，返回下标 虽然下面的两次代码都通过了测试，但是没有满足 不能重复利用两个数组中同样的元素 这个条件。带着疑问我们看了标准答案，发现也是正确答案，不过是占用资源最多的解法，最优解思路确实很妙。 12345678910111213141516/** * 执行用时 : 55 ms, 在Two Sum的Java提交中击败了31.73% 的用户 * 内存消耗 : 40.3 MB, 在Two Sum的Java提交中击败了0.99% 的用户 */class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int x = 0;x &lt; nums.length - 1;x++) &#123; for (int y = x + 1;y &lt; nums.length;y++) &#123; if ((nums[x] + nums[y]) == target) &#123; return new int[] &#123;x, y&#125;; &#125; &#125; &#125; return null; &#125;&#125; 1234567891011121314151617/** * 执行用时 : 49 ms, 在Two Sum的Java提交中击败了37.38% 的用户 * 内存消耗 : 37.8 MB, 在Two Sum的Java提交中击败了0.99% 的用户 */class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int y; // 相比上个解法只是减少了y的创建 for (int x = 0;x &lt; nums.length - 1;x++) &#123; for (y = x + 1;y &lt; nums.length;y++) &#123; if ((nums[x] + nums[y]) == target) &#123; return new int[] &#123;x, y&#125;; &#125; &#125; &#125; return null; &#125;&#125; 标准答案暴力法12345678910public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 两遍哈希表该方法利用了HashMap#containsKey函数，大幅提升了执行效率。 资源占用：执行用时 : 12 ms, 在Two Sum的Java提交中击败了68.76% 的用户内存消耗 : 38.7 MB, 在Two Sum的Java提交中击败了0.99% 的用户 12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 一遍哈希表该方法也是利用了HashMap实现，但是原理与两遍哈希表的解法不同，通过将遍历过的元素和元素下标缓存起来，在下个循环判断缓存中是否有本循环元素相加等于目标值，有则返回。妙！ 资源占用：执行用时 : 11 ms, 在Two Sum的Java提交中击败了73.97% 的用户内存消耗 : 41.2 MB, 在Two Sum的Java提交中击败了0.99% 的用户 1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution");&#125; 7 整数反转问题描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解答过程首先分析下问题： 参数：有符号整数 需求：将数字进行反转 结果：返回反转后的整数 思路： 将整数转化为字符串，取出负数符号 循环字符重新排列 将负数符号和重新排列后的字符进行组合 将组合后的字符串转化为整数 返回整数 123456789101112131415161718192021/** * 执行用时 : 45 ms, 在Reverse Integer的Java提交中击败了48.85% 的用户 * 内存消耗 : 48.5 MB, 在Reverse Integer的Java提交中击败了0.95% 的用户 */class Solution &#123; public int reverse(int x) &#123; String xStr = String.valueOf(Math.abs(x)); StringBuilder xrSb = new StringBuilder(); char[] xCharArray = xStr.toCharArray(); for (int i = xCharArray.length - 1;i &gt;= 0;i--) &#123; xrSb.append(xCharArray[i]); &#125; try &#123; int result = Integer.parseInt(xrSb.toString()); return x &gt; 0 ? result : -result; &#125; catch (Exception e) &#123; &#125; return 0; &#125;&#125; 标准答案弹出和推入数字 &amp; 溢出前进行检查 思路我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。 算法请原谅我才疏学浅并没有看懂详解。附上链接：整数反转-题解 12345678910111213class Solution &#123; public int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; &#125; return rev; &#125;&#125; 9 回文数问题描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。进阶：你能不将整数转为字符串来解决这个问题吗？ 示例1： 12输入: 121输出: true 示例2： 12输入: -121输出: false 问题分析 参数：整数，有符号 需求：判断是否是回文数 结果：返回结果 思路-1： 将整数转化为字符串 循环字符进行倒序排列，得到倒序字符串 比较参数字符串和倒序后的字符串是否相同 返回比较结果 我的答案12345678910111213141516/** * 执行用时 : 50 ms, 在Palindrome Number的Java提交中击败了84.03% 的用户 * 内存消耗 : 36 MB, 在Palindrome Number的Java提交中击败了97.33% 的用户 */class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; String xStr = String.valueOf(x); StringBuilder xrSb = new StringBuilder(); char[] xCharArray = xStr.toCharArray(); for (int i = xCharArray.length - 1;i &gt;= 0;i--) &#123; xrSb.append(xCharArray[i]); &#125; return xStr.equals(xrSb.toString()); &#125;&#125; 官方题解1234567891011121314151617181920212223public class Solution &#123; public bool IsPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber/10; &#125;&#125; 为了更好的理解，我执行了下面的代码进行分析： 12345678910111213141516171819202122232425262728class Test &#123; public static void main(String[] args) &#123; isPalindrome(121); isPalindrome(-121); isPalindrome(9); isPalindrome(12321); &#125; public static boolean isPalindrome(int x) &#123; System.out.println("------------------"); System.out.println("参数：" + x); boolean result = true; if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; result = false; &#125; else &#123; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; System.out.println("x=" + x + "; num=" + revertedNumber); &#125; result = x == revertedNumber || x == revertedNumber / 10; &#125; System.out.println("结果：" + result); return result; &#125;&#125; 输出结果： 123456789101112131415161718------------------参数：121x=12; num=1x=1; num=12结果：true------------------参数：-121结果：false------------------参数：9x=0; num=9结果：true------------------参数：12321x=1232; num=1x=123; num=12x=12; num=123结果：true 13 罗马数字转整数问题描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例： 输入 输出 III 3 IV 4 IX 9 LVIII 58 MCMXCIV 1994 问题分析刚看到这个问题时感觉比较棘手，实际分析后发现并没有那么复杂，难的是算法最优解。 字符和数值是一对一的关系 有6种特殊字符表示其他的数值 各个字符对应的数值相加，可以得到最终值 我的答案答案一思路： 首先要建立一个字符和数值的对应表，特殊字符和数值对应表 遍历字符串，先取两个一组的字符判断是否是特殊字符，不是的话取单个字符对应的数值 对所有的数值进行累加，得到最终值 返回最终值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 执行用时 : 33 ms, 在Roman to Integer的Java提交中击败了71.16% 的用户 * 内存消耗 : 42.7 MB, 在Roman to Integer的Java提交中击败了67.73% 的用户 */class Solution &#123; // 两个Map减少循环次数 private static Map&lt;String, Integer&gt; romanArray = new HashMap&lt;String, Integer&gt;(); private static Map&lt;String, Integer&gt; romanArray2 = new HashMap&lt;String, Integer&gt;(); static &#123; romanArray.put("I", 1); romanArray.put("V", 5); romanArray.put("X", 10); romanArray.put("L", 50); romanArray.put("C", 100); romanArray.put("D", 500); romanArray.put("M", 1000); romanArray2.put("IV", 4); romanArray2.put("IX", 9); romanArray2.put("XL", 40); romanArray2.put("XC", 90); romanArray2.put("CD", 400); romanArray2.put("CM", 900); &#125; public int romanToInt(String s) &#123; int result = 0; String tmpStr; Integer tmpVal; for (int i = 0; i &lt; s.length();) &#123; String startStr = String.valueOf(s.charAt(i)); if (i + 1 &lt; s.length()) &#123; tmpStr = startStr + String.valueOf(s.charAt(i + 1)); tmpVal = romanArray2.get(tmpStr); if (tmpVal == null) &#123; tmpStr = startStr; tmpVal = romanArray.get(tmpStr); &#125; &#125; else &#123; tmpStr = startStr; tmpVal = romanArray.get(tmpStr); &#125; result += tmpVal.intValue(); i += tmpStr.length(); &#125; return result; &#125;&#125; 答案二上面的代码提交后虽然通过了，但是代码看起来着实不太优雅，对效率和资源占用不太满意，随之做出了下面的修改 12345678910111213141516171819202122232425262728293031323334/** * 执行用时 : 执行用时 : 20 ms, 在Roman to Integer的Java提交中击败了96.95% 的用户 * 内存消耗 : 内存消耗 : 35.8 MB, 在Roman to Integer的Java提交中击败了99.61% 的用户 */class Solution &#123; private static Map&lt;String, Integer&gt; romanArray = new HashMap&lt;String, Integer&gt;(); static &#123; romanArray.put("I", 1); romanArray.put("V", 5); romanArray.put("X", 10); romanArray.put("L", 50); romanArray.put("C", 100); romanArray.put("D", 500); romanArray.put("M", 1000); &#125; public int romanToInt(String s) &#123; int result = 0; for (int i = 0; i &lt; s.length();i++) &#123; int val1 = romanArray.get(String.valueOf(s.charAt(i))); if (i &lt; s.length() - 1) &#123; int val2 = romanArray.get(String.valueOf(s.charAt(i + 1))); if (val1 &lt; val2) &#123; result += (val2 - val1); i++; continue; &#125; &#125; result += val1; &#125; return result; &#125;&#125; 14 最长公共前缀 这个问题给我的启发很大，分治和问题变体部分扩展了我解决某些问题的思路，应着重看下。 问题描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。说明：所有输入只包含小写字母a-z。 我的解答根据最小长度的元素，使用二分查找法截取元素字符，再拿截取的字符串去遍历数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 执行用时 : 288 ms, 在所有 Kotlin 提交中击败了69.35%的用户 * 内存消耗 : 34.6 MB, 在所有 Kotlin 提交中击败了88.24%的用户 */ class Solution &#123; fun longestCommonPrefix(strs: Array&lt;String&gt;): String &#123; if (strs.isNullOrEmpty()) return "" val shortestEl = findShortestEl(strs) if (shortestEl.isEmpty()) return "" if (checkCommonPrefix(strs, shortestEl)) return shortestEl var commonPrefix = "" var minPosition = 0 var maxPosition = shortestEl.length var position = getPosition(minPosition, maxPosition) while (position != -1) &#123; val prefix = shortestEl.substring(0, position) if (checkCommonPrefix(strs, prefix)) &#123; commonPrefix = prefix minPosition = position &#125; else &#123; maxPosition = position &#125; val tmpPosition = getPosition(minPosition, maxPosition) if (position != tmpPosition) &#123; position = tmpPosition &#125; else &#123; break &#125; &#125; return commonPrefix &#125; private fun findShortestEl(strs: Array&lt;String&gt;): String &#123; var shortestEl = strs[0] strs.forEach &#123; if (it.length &lt; shortestEl.length) &#123; shortestEl = it &#125; &#125; return shortestEl &#125; private fun getPosition(min: Int, max: Int): Int &#123; if (min &gt;= max) return -1 var diff = max - min return min + diff / 2 + diff % 2 &#125; private fun checkCommonPrefix(strs: Array&lt;String&gt;, prefix: String): Boolean &#123; strs.forEach &#123; if (!it.startsWith(prefix)) &#123; return false &#125; &#125; return true &#125;&#125; 提交后，发现执行用时有些高，想了下，我的解法在参数数组越长执行用时可能就越长。所以在解答该题时，越少遍历数组效率越高。不过看了下官方题解，发现二分查找也是其中的一个解法。 官方题解官方给出了四种解法，下面依次来看。这里只给出解题思路，具体实现代码可在官方题解找到。 水平扫描法随机取一个元素，遍历数组元素，将其取出的元素依次从尾部减去一个字符，与其他数组元素进行比较。最坏的情况下，需要进行（（取出的元素字符数 - 1） * （数组长度 - 1））次比较. 水平扫描随机取一个元素，从前往后枚举这个元素字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。 分治使用分治技巧，将原问题分成两个子问题（left，right），再将每个子问题分成两个子问题，直到不能分出子问题。在子问题中获取公共前缀，从头到尾挨个比较left和right，最终得到原问题的解。 懒得画图了，凑合看吧～～闪～～过程：原问题：[“leetcode”,”leetcod”,”leetco”,”leetc”,”leet”,”lee”,”le”,”l”]子问题：[“leetcode”,”leetcod”,”leetco”,”leetc”]和[“leet”,”lee”,”le”,”l”]子问题：[“leetcode”,”leetcod”]、[“leetco”,”leetc”]和[“leet”,”lee”],[“le”,”l”]子结果：”leetcod”、”leetc”和”lee”、”l”子问题：[“leetcod”,”leetc”]和[“lee”,”l”]子结果：”leetc”和”l”子问题：[“leetcod”,”l”]原问题结果=子问题结果=”l” 二分查找法取出一个元素，将元素字符从前到后分成两部分，每次都用前一部分字符去匹配，如果不能匹配说明答案在前一部分中，能匹配说明答案在后一部分（加上前一部分），再对匹配到的这一部分执行同样的流程，最终得到公共前缀。 过程：数组：[“leetcode”,”leetco”,”leetc”,”leet”,”lees”]取出元素：”leetcode”匹配区间：”leetcode”不能匹配匹配区间：”leet”不能匹配匹配区间：”le”能匹配匹配区间：”lee”能匹配得到答案-&gt;”lee” 问题变体原文地址 问题描述给定一些字符串数组Array，我们要找到字符串S与Array中元素的最长公共前缀。这样的查询操作可能会非常频繁。 官方解答将所有的字符（数组中所有元素的字符）存储到字典树中来优化最长公共前缀查询操作。在字典树中，从根向下的每一个节点都代表一些元素的公共前缀。要找到字符串S与Array中元素的最长公共前缀，需要从根开始找到一条最深的路径，满足以下条件： 这是所查询的字符串S的一个前缀. 路径上的每一个子节点都有且只有一个孩子。否则，找到的路径就不是所有字符串的公共前缀。 路径不包含任一元素字符串结尾代表的节点。因为最长公共前缀不可能比任意一个字符串长。 20 有效的括号问题描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 注意：空字符串可被认为是有效字符串。 我的解答思考了小半个小时，期间进行了几次尝试，没能想出解法。为了避免浪费太多时间，就去看了官方解答动画演示后进行了代码实现。我好菜，2333～ 123456789101112131415161718import java.util.*// 耗时：260 ms 内存占用：33.3 MBclass Solution &#123; private val charMap = mapOf(')' to '(', ']' to '[', '&#125;' to '&#123;') fun isValid(s: String): Boolean &#123; if (s.isEmpty()) return true val stack = Stack&lt;Char&gt;() s.forEach &#123; if (!stack.empty() &amp;&amp; stack.peek() == charMap[it]) &#123; stack.pop() &#125; else &#123; stack.push(it) &#125; &#125; return stack.empty() &#125;&#125; 官方题解我看评论中有看了题解半个小时才弄懂的，所以建议先看动画演示再细看文字解释，比较容易理解。我上面的代码实现可能不是最好的实现，所以还是建议看下官方题解。 21 合并两个有序链表问题描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 我的解答123class ListNode(var `val`: Int) &#123; var next: ListNode? = null&#125; 根据上面的数据结构定义，可以看出参数和返回值都是一个链表结构，而且参数链表都是有序的。所以只要创建一个结果链表，存放两个参数链表迭代比较得出的数据就行了，关键在于控制好指针在链表中的移动。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 执行用时:284 ms, 在所有 Kotlin 提交中击败了87.76%的用户 * 内存消耗:33.9 MB, 在所有 Kotlin 提交中击败了36.36%的用户 *//** * Example: * var li = ListNode(5) * var v = li.`val` * Definition for singly-linked list. * class ListNode(var `val`: Int) &#123; * var next: ListNode? = null * &#125; */class Solution &#123; fun mergeTwoLists(l1: ListNode?, l2: ListNode?): ListNode? &#123; if (l1 == null) return l2 if (l2 == null) return l1 // 为了使用方便，对结果进行初始化 val result = ListNode(0) // 定义指针变量在Node间移动 var tmpResult = result var node1: ListNode? = l1 var node2: ListNode? = l2 fun refreshResult(node: ListNode) &#123; tmpResult.next = ListNode(node.`val`) tmpResult = tmpResult.next ?: tmpResult &#125; loop@ while (true) &#123; when &#123; node1 == null || node2 == null -&gt; &#123; tmpResult.next = node1 ?: node2 break@loop &#125; node1.`val` &lt; node2.`val` -&gt; &#123; refreshResult(node1) node1 = node1.next &#125; else -&gt; &#123; refreshResult(node2) node2 = node2.next &#125; &#125; &#125; return result.next &#125;&#125; 官方解答官方解答地址 递归将两个链表中头部较小的值，与合并剩下的两个链表的结果进行合并。递归这个过程，直到得出最终结果。官方的这个Java代码实现真是简洁，忍不住放了出来。但是实际开发中可不要这么写，因为改变了参数链表的内容。 123456789101112131415161718class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 迭代将元素少的链表逐一插入到另一个链表中正确的位置。这个解法字面上就能理解，不再多诉。 26 删除排序数组中的重复项 问题描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 问题分析这个问题初次看时有些看不明白，有几个“点”需要知道。 理解下“原地算法”。 不能使用额外的数组去解决问题。 需要删除原数组中的重复元素，但不需要考虑数组中超出新长度后面的元素。如：输入[1,1,2]后，返回值是2，数组被修改为[1,2,2]。 我的解答最方便的做法是创建一个数组，存放过滤后的元素，在以往的开发中经常这么做。今天看到这道题，也是第一次认真的思考了下此类题的更好的解法。 123456789101112131415161718192021/** * 执行用时:388ms,在所有Kotlin提交中击败了73.77%的用户 * 内存消耗:40.1 MB, 在所有Kotlin提交中击败了70.59%的用户 */class Solution &#123; fun removeDuplicates(nums: IntArray): Int &#123; if (nums.size &lt;= 1) return nums.size var pos1 = 0 var pos2 = 1 while (pos2 &lt; nums.size) &#123; if (nums[pos1] != nums[pos2]) &#123; pos1++ nums[pos1] = nums[pos2] pos2++ &#125; else &#123; pos2++ &#125; &#125; return pos1 + 1 &#125;&#125; 官方题解看完后才发现，我的解法就是双指针法。官方题解地址 双指针法数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。 1234567891011public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1;&#125; 27 移除元素 此题的官方地址 问题描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例1: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 问题分析此题和删除排序数组中的重复项这道题目很相似，都要满足原地算法，并且不能使用额外的数组去解决问题，此外，解答时不需要考虑数组中超出新长度后面的元素。 我的解答由于刚做了上面删除排序数组中的重复项这道算法题，所以很简单的就写出了下面的答案。解答实现了两次，解题思路一样，只是具体实现有所优化。然后才发现LeetCode提交代码的结果（执行用时和内存消耗）并不准确，所以关于这个结果大家看看就好。 解题思路：用一个指针变量I记录在数组中的位置，如果I位置的元素不需要移除将I递增，否则检查I后面是否还有不需要移除的元素，有的话将这个元素值和I位置的元素调换位置。然后递增I继续向后检查。最后I的值也就是数组的新长度。 代码实现一： 123456789101112131415161718192021222324252627282930/** * 执行用时:276ms, 在所有Kotlin提交中击败了90.63%的用户 * 内存消耗:34.7MB, 在所有Kotlin提交中击败了54.55%的用户 */class Solution &#123; fun removeElement(nums: IntArray, `val`: Int): Int &#123; if (nums.isEmpty()) return 0 var count = 0 nums.forEachIndexed &#123; index, i -&gt; if (i != `val`) &#123; count++ &#125; else if (index &lt; nums.lastIndex) &#123; var hasNext = false for (pos in index + 1..nums.lastIndex) &#123; if (nums[pos] != `val`) &#123; nums[index] = nums[pos] nums[pos] = `val` count++ hasNext = true break &#125; &#125; if (!hasNext) &#123; return count &#125; &#125; &#125; return count &#125;&#125; 代码实现二： 123456789101112131415161718192021222324252627/** * 执行用时:284ms, 在所有Kotlin提交中击败了81.25%的用户 * 内存消耗:35.4MB, 在所有Kotlin提交中击败了9.09%的用户 */class Solution &#123; fun removeElement(nums: IntArray, `val`: Int): Int &#123; if (nums.isEmpty()) return 0 var count = 0 while (count &lt; nums.size) &#123; if (nums[count] != `val`) count++ else if (count &lt; nums.lastIndex) &#123; var goOn = false for (pos in count + 1..nums.lastIndex) &#123; if (nums[pos] != `val`) &#123; nums[count] = nums[pos] nums[pos] = `val` count++ goOn = pos &lt; nums.lastIndex break &#125; &#125; if (!goOn) break &#125; else break &#125; return count &#125;&#125; 官方题解看完官方题解后，发现代码实现其实可以更简洁高效，惭愧～ 提示： 尝试双指针法。 你是否使用“元素顺序可以更改”这一属性？ 当要删除的元素很少时会发生什么？ 双指针12345678910public int removeElement(int[] nums, int val) &#123; int i = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != val) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i;&#125; 双指针 — 当要删除的元素很少时与上面解法的区别是，考虑到了数组包含很少的要删除的元素的情况。 1234567891011121314public int removeElement(int[] nums, int val) &#123; int i = 0; int n = nums.length; while (i &lt; n) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; // reduce array size by one n--; &#125; else &#123; i++; &#125; &#125; return n;&#125; 28 实现strStr() 此题的官方地址 问题描述给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = “hello”, needle = “ll”输出: 2 示例 2: 输入: haystack = “aaaaa”, needle = “bba”输出: -1 说明:当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 我的解答String.indexOf()看到该题，就想到了Java中有 String.indexOf() 这个函数可以直接调用。现成的轮子，不用白不用～ 1234567891011/* 执行用时 : 256 ms, 在所有 Kotlin 提交中击败了 91.30% 的用户 内存消耗 : 34.8 MB, 在所有 Kotlin 提交中击败了 62.50% 的用户*/class Solution &#123; fun strStr(haystack: String, needle: String): Int &#123; if (needle.isEmpty()) return 0 /* Kotlin函数 */ return haystack.indexOf(needle) &#125;&#125; 双指针虽然有现成的轮子可以使用，但是做算法题的目的还没有达到。所以费了点功夫，写出了下面的代码。没错，也是用双指针法进行求解，谁让前面几道算法题用双指针多呢～ 1234567891011121314151617181920212223242526272829303132/* 执行用时 : 284 ms, 在所有 Kotlin 提交中击败了 43.48% 的用户 内存消耗 : 34.5 MB, 在所有 Kotlin 提交中击败了 62.50% 的用户*/class Solution &#123; fun strStr(haystack: String, needle: String): Int &#123; if (needle.isEmpty()) return 0 if (needle.length &gt; haystack.length) return -1 var walkIndex = 0 var index = 0 while (index &lt;= haystack.lastIndex) &#123; // 满足了要求，这里haystack长度大于needle长度 if (walkIndex &gt; needle.lastIndex) &#123; return index - needle.length &#125; val char = haystack[index] if (char == needle[walkIndex]) &#123; walkIndex++ &#125; else &#123; index -= walkIndex walkIndex = 0 &#125; index++ &#125; // haystack长度等于needle长度，并满足了要求（循环结束walkIndex未被重置为0） if (walkIndex == needle.length) &#123; return index - needle.length &#125; return -1 &#125;&#125; 官方题解此题没有官方题解，还是看下Java中 String.indexOf 这个轮子的实现吧。注释部分使用Google翻译翻译了一下，就是这么贴心～ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * String和StringBuffer共享的代码进行搜索。 * 该source是要搜索的字符数组和目标是要搜索的字符串。 * * @param source 正在搜索的字符. * @param sourceOffset 源字符串的偏移量. * @param sourceCount 源字符串的计数. * @param target 要搜索的字符. * @param targetOffset 目标字符串的偏移量. * @param targetCount 目标字符串的计数. * @param fromIndex 要开始搜索的索引. */static int indexOf(char[] source, int sourceOffset, int sourceCount,char[] target, int targetOffset, int targetCount,int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* 寻找第一个字符. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* 找到第一个字符，现在看看v2的其余部分 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* 找到整个字符串. */ return i - sourceOffset; &#125; &#125; &#125; return -1;&#125; 35 搜索插入位置 此题的官方地址 问题描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2 示例 2: 输入: [1,3,5,6], 2输出: 1 示例 3: 输入: [1,3,5,6], 7输出: 4 示例 4: 输入: [1,3,5,6], 0输出: 0 我的解答这道题非常简单，随手便写出了下面的代码（暴力法）。如果考虑到数组较大的情况，还有其他的解法：二分查找法。 123456789101112/*执行用时 : 280 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户内存消耗 : 34.8 MB, 在所有 Kotlin 提交中击败了 64.29% 的用户*/class Solution &#123; fun searchInsert(nums: IntArray, target: Int): Int &#123; for ((index, el) in nums.withIndex()) &#123; if (target &lt;= el) return index &#125; return nums.size &#125;&#125; 精选解答二分查找法 作者：liweiwei1419链接：点这里来源：力扣（LeetCode） 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int len = nums.length; if (nums[len - 1] &lt; target) &#123; return len; &#125; int left = 0; int right = len - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; // 等于的情况最简单，我们应该放在第 1 个分支进行判断 if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; // 题目要我们返回大于或者等于目标值的第 1 个数的索引 // 此时 mid 一定不是所求的左边界， // 此时左边界更新为 mid + 1 left = mid + 1; &#125; else &#123; // 既然不会等于，此时 nums[mid] &gt; target // mid 也一定不是所求的右边界 // 此时右边界更新为 mid - 1 right = mid - 1; &#125; &#125; // 注意：一定得返回左边界 left， // 如果返回右边界 right 提交代码不会通过 // 【注意】下面我尝试说明一下理由，如果你不太理解下面我说的，那是我表达的问题 // 但我建议你不要纠结这个问题，因为我将要介绍的二分查找法模板，可以避免对返回 left 和 right 的讨论 // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1 // 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1 // 根据题意应该返回 left， // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right return left; &#125;&#125; 38 报数 此题的官方地址 问题描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1 —&gt; 12 —&gt; 113 —&gt; 214 —&gt; 12115 —&gt; 111221省略～1 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1输出: “1” 示例 2: 输入: 4输出: “1211” 问题分析这个算法问题我缕了几遍，着实没看懂，去评论区一看同样情况的大有人在，最后看了网友的评论才理解题目的意思，2333～题目的意思是对序列前一个数进行报数。数列第一项是1，那第二项就报第一项的有1个1，输出11。然后第三项就在第二项的基础上报数，第二项是11，第三项不就是2个1么，然后输出21。 我的解答字典使用Map集合将 1～30 所有的答案预先存放到Map集合，调用函数时取出返回。该方法虽然效率高、占用内存空间小，但是只适用于求解该题，我们可以换个更优雅的方法来解决。 1234567891011121314151617181920212223242526272829303132333435363738394041/*执行用时 : 236 ms, 在所有 Kotlin 提交中击败了92.31%的用户内存消耗 : 32.5 MB, 在所有 Kotlin 提交中击败了100.00%的用户*/class Solution &#123; fun countAndSay(n: Int): String &#123; val map = mapOf( 1 to "1", 2 to "11", 3 to "21", 4 to "1211", 5 to "111221", 6 to "312211", 7 to "13112221", 8 to "1113213211", 9 to "31131211131221", 10 to "13211311123113112211", 11 to "11131221133112132113212221", 12 to "3113112221232112111312211312113211", 13 to "1321132132111213122112311311222113111221131221", 14 to "11131221131211131231121113112221121321132132211331222113112211", 15 to "311311222113111231131112132112311321322112111312211312111322212311322113212221", 16 to "132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211", 17 to "11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221", 18 to "31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211", 19 to "1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221", 20 to "11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211", 21 to "311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221", 22 to "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211", 23 to "111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221", 24 to "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211", 25 to "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221", 26 to "1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211", 27 to "31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221", 28 to "13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211", 29 to "11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221", 30 to "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211" ) return map.getValue(n) &#125;&#125; 常规法使用字典预存1的报数，在获取n的报数时，从1～n依次进行翻译，并将1～n中间的结果存入字典，方便下次直接使用。没有更深入的去研究，下面的实现执行用时有些高。 123456789101112131415161718192021222324252627282930313233343536373839404142/*执行用时 : 272 ms, 在所有 Kotlin 提交中击败了46.15%的用户内存消耗 : 33.7 MB, 在所有 Kotlin 提交中击败了100.00%的用户*/class Solution &#123; private val MAP = mutableMapOf(1 to "1") fun countAndSay(n: Int): String &#123; var countOff = MAP[n] if (countOff != null) return countOff for (num in 1..n) &#123; val mapVal = MAP[num] if (mapVal != null) &#123; countOff = mapVal &#125; else &#123; countOff = transform(countOff!!) MAP[num] = countOff &#125; &#125; return countOff!! &#125; private fun transform(str: String): String &#123; val countOff = StringBuilder() var count = 0 // 有几个数（重复次数） str.forEachIndexed &#123; index, c -&gt; if (c != str[index - count]) &#123; countOff.append(count) countOff.append(str[index - count]) count = 1 &#125; else &#123; count++ &#125; if (index == str.lastIndex) &#123; countOff.append(count) countOff.append(str[index]) &#125; &#125; return countOff.toString() &#125;&#125; 官方题解此题官方没有给出解答，我找了个优质题解来看下。作者：jimmy00745原文地址来源：力扣（LeetCode） 具体思路： 先设置上一人为’1’ 开始外循环 每次外循环先置下一人为空字符串，置待处理的字符num为上一人的第一位，置记录出现的次数为1 开始内循环，遍历上一人的数，如果数是和num一致，则count增加。 若不一致，则将count和num一同添加到next_person报的数中，同时更新num和count 别忘了更新next_person的最后两个数为上一个人最后一个字符以及其出现次数！ 1234567891011121314class Solution: def countAndSay(self, n: int) -&gt; str: prev_person = '1' for i in range(1,n): next_person, num, count = '', prev_person[0], 1 for j in range(1,len(prev_person)): if prev_person[j] == num:count += 1 else: next_person += str(count) + num num = prev_person[j] count = 1 next_person += str(count) + num prev_person = next_person return prev_person 53 最大子序和 此题的官方地址 问题描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 我的解答我在尝试求解该题时，陷入了思维误区，代码实现也越来越复杂，在继续尝试一番后无奈放弃。转到评论区，看到有人说这道题是清华考研专业课算法题，能上清华的果然有实力～ 精选解答动态规划动态规划的思路：声明两个变量，一个变量存最终结果，一个缓存对目前状态有增益的子序列之和。如果之前缓存的子序列之和大于零，说明其是对之后状态有增益的，加上当前状态的值并更新缓存；反之则舍弃，只取当前状态的值更新至缓存。 作者：guanpengchn链接：原文地址来源：力扣（LeetCode） 思路： 这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来 动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans 如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字 如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果 时间复杂度：O(n) 123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; int ans = nums[0]; int sum = 0; for (int num: nums) &#123; if (sum &gt; 0) &#123; sum += num; &#125; else &#123; sum = num; &#125; ans = Math.max(ans, sum); &#125; return ans; &#125;&#125; 分治法还记得吗？分治法在前面最长公共前缀这道算法题出现过。 作者：pandawakaka链接：原文地址来源：力扣（LeetCode） 分治法其他题解里将的很清楚了。其实就是它的最大子序和要么在左半边，要么在右半边，要么是穿过中间，对于左右边的序列，情况也是一样，因此可以用递归处理。中间部分的则可以直接计算出来，时间复杂度应该是 O(nlogn)。 12345678910111213141516171819202122232425class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: n = len(nums) #递归终止条件 if n == 1: return nums[0] else: #递归计算左半边最大子序和 max_left = self.maxSubArray(nums[0:len(nums) // 2]) #递归计算右半边最大子序和 max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)]) #计算中间的最大子序和，从右到左计算左边的最大子序和，从左到右计算右边的最大子序和，再相加 max_l = nums[len(nums) // 2 - 1] tmp = 0 for i in range(len(nums) // 2 - 1, -1, -1): tmp += nums[i] max_l = max(tmp, max_l) max_r = nums[len(nums) // 2] tmp = 0 for i in range(len(nums) // 2, len(nums)): tmp += nums[i] max_r = max(tmp, max_r) #返回三个中的最大值 return max(max_right,max_left,max_l+max_r) 58 最后一个单词的长度 链接：原文地址来源：力扣（LeetCode） 问题描述给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。如果不存在最后一个单词，请返回 0 。说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: “Hello World”输出: 5 我的解答目前为止，得到的最好的解答成绩，美滋滋～。由于解该题并没有花费太多时间，所以又思考了一下其他解法： 将字符串中的单词裁剪出来存放到集合，获取最后一个集合元素的长度。 分治法，只是想到能处理该问题，并没有写代码实现。 12345678910111213141516171819/* 执行用时 : 244 ms, 在所有 Kotlin 提交中击败了 100.00% 的用户 内存消耗 : 33.1 MB, 在所有 Kotlin 提交中击败了 100.00% 的用户 */class Solution &#123; fun lengthOfLastWord(s: String): Int &#123; var length = 0 var lastLength = length s.forEach &#123; c -&gt; if (c != ' ') &#123; length++ &#125; else if (length &gt; 0) &#123; lastLength = length length = 0 &#125; &#125; return if (length &gt; 0) length else lastLength &#125;&#125; 注：下面的代码实现并不适合求解该题，更适用于获取字符串中的所有单词。 123456789101112131415161718192021222324/* 执行用时 : 300 ms, 在所有 Kotlin 提交中击败了 27.27% 的用户 内存消耗 : 34.4 MB, 在所有 Kotlin 提交中击败了 66.67% 的用户 */class Solution &#123; fun lengthOfLastWord(s: String): Int &#123; val words = mutableListOf&lt;String&gt;() var startIndex: Int? = null s.forEachIndexed &#123; index, c -&gt; if (c == ' ') &#123; if (startIndex != null &amp;&amp; index &gt; startIndex!!) &#123; words.add(s.substring(startIndex!!, index)) startIndex = null &#125; &#125; else if (startIndex == null) &#123; startIndex = index &#125; if (startIndex != null &amp;&amp; index == s.lastIndex) &#123; words.add(s.substring(startIndex!!)) &#125; &#125; return if (words.isEmpty()) 0 else words[words.lastIndex].length &#125;&#125; 精选题解作者：guanpengchn链接：原文地址来源：力扣（LeetCode） 看了该题解后，发现可以继续优化我的解法，我的解法是从前往后找最后一个单词，其实可以反过来从后往前找。 思路 标签：字符串遍历 从字符串末尾开始向前遍历，其中主要有两种情况 第一种情况，以字符串”Hello World”为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词”World”的长度5 第二种情况，以字符串”Hello World “为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为”World”，长度为5 所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度 时间复杂度：O(n)，n为结尾空格和结尾单词总体长度 12345678910class Solution &#123; public int lengthOfLastWord(String s) &#123; int end = s.length() - 1; while(end &gt;= 0 &amp;&amp; s.charAt(end) == ' ') end--; if(end &lt; 0) return 0; int start = end; while(start &gt;= 0 &amp;&amp; s.charAt(start) != ' ') start--; return end - start; &#125;&#125; 66 加一 链接：原文地址来源：力扣（LeetCode） 问题描述给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 我的解答类型转换求解思路：将IntArray转换为整数，+1后再转换回IntArray进行返回。 1234567891011121314151617181920212223242526/* 执行用时 : 288 ms, 在所有 Kotlin 提交中击败了 66.67% 的用户 内存消耗 : 33.2 MB, 在所有 Kotlin 提交中击败了 60.00% 的用户 */class Solution &#123; fun plusOne(digits: IntArray): IntArray &#123; return (digits.toBigDecimal() + BigDecimal(1)).toString().toIntArray() &#125; private fun IntArray.toBigDecimal(): BigDecimal &#123; val builder = StringBuilder() for (el in this) &#123; builder.append(el) &#125; // 如果使用 toInt 和 toLong，值超出类型范围会报下面的错误：java.lang.NumberFormatException. return builder.toString().toBigDecimal() &#125; private fun String.toIntArray(): IntArray &#123; val intArray = IntArray(this.length) this.forEachIndexed &#123; index, c -&gt; intArray[index] = c.toString().toInt() &#125; return intArray &#125;&#125; 数组遍历遍历数组求解，该想到的点都想到了，就是代码实现惨不忍睹，原因一是想到IntArray是指针变量，该题需要返回值那就不应该修改原数组的元素，原因之二是这次求解有些依赖Kotlin的语法糖了，不用的话代码可以写的更简洁一些。 1234567891011121314151617181920212223242526272829303132/* 执行用时 : 296 ms, 在所有 Kotlin 提交中击败了 66.67% 的用户 内存消耗 : 35.9 MB, 在所有 Kotlin 提交中击败了 60.00% 的用户 */class Solution &#123; fun plusOne(digits: IntArray): IntArray &#123; if (digits[digits.lastIndex] &lt; 9) &#123; return digits.clone().apply &#123; this[lastIndex] = this[lastIndex] + 1 &#125; &#125; val newArray = MutableList(digits.size + 1) &#123; -1 &#125; var plus1Index = digits.size // 记录需要+1的位置 for (index in digits.lastIndex downTo 0) &#123; if (plus1Index &lt; 0) &#123; newArray[index + 1] = digits[index] continue &#125; if (digits[index] &lt; 9) &#123; newArray[index + 1] = digits[index] + 1 plus1Index = -1 &#125; else &#123; newArray[index + 1] = 0 plus1Index-- &#125; &#125; if (plus1Index &gt;= 0) &#123; newArray[0] = 1 &#125; else &#123; newArray.removeAt(0) &#125; return newArray.toIntArray() &#125;&#125; 精选题解作者：yhhzw链接：原文地址来源：力扣（LeetCode） 根据题意加一，没错就是加一这很重要，因为它是只加一的所以有可能的情况就只有两种： 除9之外的数字加一； 数字9。 加一得十进一位个位数为0加法运算如不出现进位就运算结束了且进位只会是一。所以只需要判断有没有进位并模拟出它的进位方式，如十位数加1个位数置为0，如此循环直到判断没有再进位就退出循环返回结果。然后还有一些特殊情况就是当出现99、999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位。 123456789101112class Solution &#123; public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; digits[i]++; digits[i] = digits[i] % 10; if (digits[i] != 0) return digits; &#125; digits = new int[digits.length + 1]; digits[0] = 1; return digits; &#125;&#125; 由于后期改成了使用算法标签进行解答，不再根据顺序和页数进行分类，所以将下面的题移了过来。 860 柠檬水找零LeetCode简单算法题：860～1013 LeetCode官网地址 闹了个乌龙，打算每篇博客50到题，从简单算法题第一道往后一道道刷的，结果不知怎的从第五页开始了。。。 so，这篇博客就先做了一道放在了这里，立个flag，看看刷到这里需要多久～ 期待我尽早刷到这里吧，哈哈 问题描述在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 解答过程（2019.03.25）这是我最开始提交的Java实现，结果提交后发现错了，梳理了几遍后依旧没有头绪。迫不得已点击了答案，发现把该问题想简单了：顾客支付的钱只有固定的5，10，20三种，只需要梳理三种支付方式可能出现的情况，就能正确解答。 123456789101112131415161718class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills == null || bills.length &lt;= 0) return false; int change = 0; int diff = 0; for (int bill : bills) &#123; diff = bill - 5; if (diff == 0) &#123; change += bill;//这里bill等于5 &#125; else if (diff &gt; 0 &amp;&amp; change &gt;= diff) &#123; change = change - diff + bill; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125; 官方解答思路最初，没有5美元和10美元的钞票，收到20美元的钞票后，该20美元不能用于找零。 顾客支付5美元钞票，得到一张5美元的钞票 顾客支付10美元钞票 有5美元钞票，找零 没有5美元钞票，无法找零，返回false 顾客支付20美元钞票 有5美元和10美元钞票，用一张10美元和5美元钞票找零更有利于以后找零 只有5美元钞票，用三张5美元进行找零 其他情况，无法找零。 只有20美元钞票 只有10美元钞票 没有钞票 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; // 定义局部变量记录5美元和10美元钞票的数量 int five = 0, ten = 0; for (int bill: bills) &#123; // @1 第一种情况 if (bill == 5) five++; // @2 第二种情况 else if (bill == 10) &#123; if (five == 0) return false; five--; ten++; &#125; // @3 第三种情况 else &#123; // @3.1 第三种情况的第一种可能 if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123; five--; ten--; &#125; // @3.2 第三种情况的第二种可能 else if (five &gt;= 3) &#123; five -= 3; &#125; // @3.3 第三种情况的第三种可能 else &#123; // 无法找零 return false; &#125; &#125; &#125; // 能找零 return true; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>学习</tag>
        <tag>简单算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作随身移动系统]]></title>
    <url>%2Fblog%2F%E5%88%B6%E4%BD%9C%E9%9A%8F%E8%BA%AB%E7%A7%BB%E5%8A%A8%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[计划内容，内容待补充]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>软件</tag>
        <tag>系统</tag>
        <tag>硬件</tag>
        <tag>WinToUSB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你认识LocalBroadcastManager]]></title>
    <url>%2Fblog%2F%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86LocalBroadcastManager%2F</url>
    <content type="text"><![CDATA[前言我们在Android应尽量避免使用隐式Intent广播传递信息，为什么这么说？原因有下面几点： 意外接收：如果同时维护几个项目，不同项目中难免会存在代码复用的情况，这时若安装了两个注册过同样 Action 广播的APP，一个APP通过Context.sendBroadcast()发送的隐式广播也会被另一个APP接收到，并进行相应的操作，可能会产生意想不到的风险。 敏感信息外泄：发送的隐式广播，可能会被恶意应用注册监听该广播的 receiver 获取到Intent中传递的敏感信息，并进行其他危险的操作。 Intent拦截：如果发送的广播为使用Context.sendOrderedBroadcast()方法发送的有序广播，优先级较高的恶意 receiver 若直接丢弃该广播，会导致服务无法正常使用，或者广播结果被填充恶意数据。 基于以上的几点，会发现使用隐式Intent广播风险很高，那么怎么解决这个问题呢？首先，我们需要明确广播是否仅限于应用内使用。若需要在应用间传递广播，应尽量避免传递敏感信息；否则，可以使用LocalBroadcastManager.sendBroadcast()实现，这样就避免了意外接收广播，敏感信息外泄和Intent拦截的风险。 LocalBroadcastManager源码分析LocalBroadcastManager的源码并不多，总共也就不到300行，我们来分析下是怎么它的实现。 单例模式首先，从下面这几行代码会发现LocalBroadcastManager使用了延迟加载的单例模式保证类对象的唯一性。 123456789@NonNullpublic static LocalBroadcastManager getInstance(@NonNull Context context) &#123; synchronized(mLock) &#123; if (mInstance == null) &#123; mInstance = new LocalBroadcastManager(context.getApplicationContext()); &#125; return mInstance; &#125;&#125; 内部类再看LocalBroadcastManager的两个静态内部类。 123456789private static final class ReceiverRecord &#123; final IntentFilter filter; final BroadcastReceiver receiver; // 请自行分析这两个变量的作用 boolean broadcasting; boolean dead; // 省略了构造函数 // 省略了toString函数&#125; 12345private static final class BroadcastRecord &#123; final Intent intent; final ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt; receivers; // 省略了构造函数&#125; ReceiverRecord类记录了Intent过滤器和BroadcastReceiver对象，BroadcastRecord记录了发送的Intent和一个ReceiverRecord的集合，这个集合是用来做什么的呢？目前猜测存放的应该是需要接收Intent的所有BroadcastReceiver对象，带着这个疑问继续看它的关键成员变量。 成员变量和关键函数123private final HashMap&lt;BroadcastReceiver, ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt;&gt; mReceivers = new HashMap();private final HashMap&lt;String, ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt;&gt; mActions = new HashMap();private final ArrayList&lt;LocalBroadcastManager.BroadcastRecord&gt; mPendingBroadcasts = new ArrayList(); 想理解这几个变量的作用，需要去看对应的代码。 下面的代码是LocalBroadcastManager#registerReceiver()函数，从代码注释中的 标识1 标识2 可以看出变量名为mReceivers的HashMap存放通过注册的BroadcastReceiver（广播接收者）对象和存放了广播接收者信息的ReceiverRecord。从 标识4 标识5 不难看出变量名为mActions的HashMap存放的是通过LocalBroadcastManager#registerReceiver()方法注册的Action事件和这个事件所对应的所有ReceiverRecord。 1234567891011121314151617181920212223242526272829// 注册BroadcastReceiver（广播接收者）public void registerReceiver(@NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter) &#123; synchronized(this.mReceivers) &#123; LocalBroadcastManager.ReceiverRecord entry = new LocalBroadcastManager.ReceiverRecord(filter, receiver); ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt; filters = (ArrayList)this.mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList(1); /** 标识1：以BroadcastReceiver为键，ReceiverRecord集合为值存放到mReceivers中 */ this.mReceivers.put(receiver, filters); &#125; /** 标识2：将ReceiverRecord存放到ReceiverRecord集合中 */ filters.add(entry); /** 标识3：遍历需要注册的Action集合 */ for(int i = 0; i &lt; filter.countActions(); ++i) &#123; String action = filter.getAction(i); ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt; entries = (ArrayList)this.mActions.get(action); if (entries == null) &#123; entries = new ArrayList(1); /** 标识4：以Action为键，Action对应的ReceiverRecord集合为值，存放到mActions中 */ this.mActions.put(action, entries); &#125; /** 标识5：将ReceiverRecord存放到Action对应的ReceiverRecord集合中 */ entries.add(entry); &#125; &#125;&#125; 怎么还有个变量没有解释呢？别着急，想知道另一个变量的作用，需要看另一个函数的代码，那就是sendBroadcast函数。从下面的代码注释中，可以看出sendBroadcast函数的作用就是从前面介绍的mActions两个集合中取出需要通知的广播接收者，使用 BroadcastRecord 进行记录，并触发执行executePendingBroadcasts函数罢了。 123456789101112131415// 发送广播函数public boolean sendBroadcast(@NonNull Intent intent) &#123; // 省略代码：标识1 根据Intent中的信息从mActions中 if (receivers != null) &#123; // 省略代码 /** 标识2：将发送的Intent和所有需要接收这个Intent的广播接收者封装为BroadcastRecord，并将其存放到mPendingBroadcasts中*/ this.mPendingBroadcasts.add(new LocalBroadcastManager.BroadcastRecord(intent, receivers)); /** 标识3：发送了一个Handler消息，追踪后发现，最后调用了executePendingBroadcasts函数 */ if (!this.mHandler.hasMessages(1)) &#123; this.mHandler.sendEmptyMessage(1); &#125; return true; &#125; // 省略代码&#125; 而executePendingBroadcasts从函数名和前面的逻辑就可以猜到这个函数肯定是通知广播接收器接收Intent，并执行各自操作的最终函数。研究下面这个函数的代码后发现我们的猜测果然没有错，函数就是通过循环调用广播接收器的回调函数来实现 _广播_ 的功能的。什么本地广播管理器嘛，名头这么大，原来本质上就是通过普通的回调实现的。 1234567891011121314151617181920212223242526272829void executePendingBroadcasts() &#123; // 注意这里是死循环 while(true) &#123; LocalBroadcastManager.BroadcastRecord[] brs; synchronized(this.mReceivers) &#123; int N = this.mPendingBroadcasts.size(); if (N &lt;= 0) &#123; // 当所有的广播接收器都通知到后，跳出死循环 return; &#125; // 取出所有的BroadcastRecord存放到临时列表中，并清空原列表 brs = new LocalBroadcastManager.BroadcastRecord[N]; this.mPendingBroadcasts.toArray(brs); this.mPendingBroadcasts.clear(); &#125; // 循环临时列表调用广播接收者的onReceive函数 for(int i = 0; i &lt; brs.length; ++i) &#123; LocalBroadcastManager.BroadcastRecord br = brs[i]; int nbr = br.receivers.size(); for(int j = 0; j &lt; nbr; ++j) &#123; LocalBroadcastManager.ReceiverRecord rec = (LocalBroadcastManager.ReceiverRecord)br.receivers.get(j); if (!rec.dead) &#123; rec.receiver.onReceive(this.mAppContext, br.intent); &#125; &#125; &#125; &#125;&#125; 总结前面通过分析LocalBroadcastManager的源码，我们对LocalBroadcastManager有了更深的理解。我们发现它并没有很复杂的逻辑实现，但却提供了很有用的功能。同时我们只是分析了它的大致逻辑实现原理，并没有对细节做分析，比如：synchronized关键字的使用，为什么通过Handler来触发执行函数？而executePendingBroadcasts函数中为什么要使用死循环来实现？这些细节就要自己去分析理解了，这样才能提高自己的代码水平。我当然已经想通了，哈哈～ LocalBroadcastManager封装为了方便使用LocalBroadcastManager，我对LocalBroadcastManager进行了简单的封装，不仅有Java语言实现，还有Kotlin语言的实现。顺便说一下，Kotlin真好用！ Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.content.LocalBroadcastManager;/** * @Desc LocalBroadcastManager工具类 * @Author wangwh * @Date 2019-03-14 15:06 */@SuppressWarnings("WeakerAccess")public class LBMUtils &#123; private LBMUtils() &#123; throw new RuntimeException("Do not need instantiate!"); &#125; @NonNull public static LocalBroadcastManager getBroadcastManager(@NonNull Context ctx) &#123; return LocalBroadcastManager.getInstance(ctx); &#125; @Nullable public static IntentFilter getIntentFilter(@NonNull String... actions) &#123; IntentFilter filter = null; if (actions.length &gt; 0) &#123; filter = new IntentFilter(); for (String action : actions) &#123; filter.addAction(action); &#125; &#125; return filter; &#125; /** * @Desc 通过Action注册广播接收者 * @Param [ctx, receiver, actions] */ public static void registerReceiver(@NonNull Context ctx, @NonNull BroadcastReceiver receiver, @NonNull String... actions) &#123; IntentFilter filter = getIntentFilter(actions); if (filter != null) &#123; registerReceiver(ctx, receiver, filter); &#125; &#125; /** * @Desc 通过IntentFilter注册广播接收者 * @Param [ctx, receiver, filter] */ public static void registerReceiver(@NonNull Context ctx, @NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter) &#123; getBroadcastManager(ctx).registerReceiver(receiver, filter); &#125; /** * @Desc 注销广播接收者 * @Param [ctx, receiver] */ public static void unRegisterReceiver(@NonNull Context ctx, BroadcastReceiver receiver) &#123; getBroadcastManager(ctx).unregisterReceiver(receiver); &#125; /** * @Desc 通过Action发送广播 * @Param [ctx, action] */ public static void sendBroadcast(@NonNull Context ctx, @NonNull String action) &#123; sendBroadcast(ctx, new Intent(action)); &#125; /** * @Desc 通过intent发送广播 * @Param [ctx, intent] */ public static void sendBroadcast(@NonNull Context ctx, @NonNull Intent intent) &#123; getBroadcastManager(ctx).sendBroadcast(intent); &#125; /** * @Desc 通过Action同步发送广播 * @Param [ctx, action] */ public static void sendBroadcastSync(@NonNull Context ctx, @NonNull String action) &#123; sendBroadcastSync(ctx, new Intent(action)); &#125; /** * @Desc 通过Intent同步发送广播 * @Param [ctx, intent] */ public static void sendBroadcastSync(@NonNull Context ctx, @NonNull Intent intent) &#123; getBroadcastManager(ctx).sendBroadcastSync(intent); &#125;&#125; Kotlin实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@file:Suppress("NOTHING_TO_INLINE", "unused", "DEPRECATION", "SpellCheckingInspection")import android.app.Fragmentimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Intentimport android.content.IntentFilterimport android.support.v4.app.Fragment as FragmentV4import android.support.v4.content.LocalBroadcastManagerimport android.view.Viewimport org.jetbrains.anko.AnkoContext/** * @Desc LocalBroadcastManager扩展 Kotlin API * @Author wangwh * @Date 2019-03-06 15:46 */fun getIntentFilter(vararg actions: String): IntentFilter &#123; val filter = IntentFilter() for (action in actions) &#123; filter.addAction(action) &#125; return filter&#125;// Context 的扩展实现inline fun Context.unRegisterReceiver(receiver: BroadcastReceiver) = getBroadcastManager().unregisterReceiver(receiver)inline fun Context.getBroadcastManager(): LocalBroadcastManager = LocalBroadcastManager.getInstance(this)inline fun Context.sendBroadcast(action: String) = sendBroadcast(Intent(action))inline fun Context.sendBroadcastSync(intent: Intent) = getBroadcastManager().sendBroadcastSync(intent)// 同上实现，对 AnkoContext 进行扩展inline fun AnkoContext&lt;*&gt;.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = ctx.registerReceiver(receiver, filter)inline fun AnkoContext&lt;*&gt;.unRegisterReceiver(receiver: BroadcastReceiver) = ctx.unRegisterReceiver(receiver)inline fun AnkoContext&lt;*&gt;.sendBroadcast(action: String) = ctx.sendBroadcast(action)inline fun AnkoContext&lt;*&gt;.sendBroadcast(intent: Intent) = ctx.sendBroadcast(intent)inline fun AnkoContext&lt;*&gt;.sendBroadcastSync(action: String) = ctx.sendBroadcast(action)inline fun AnkoContext&lt;*&gt;.sendBroadcastSync(intent: Intent) = ctx.sendBroadcastSync(intent)// 同上实现，对 View 进行扩展inline fun View.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = context.registerReceiver(receiver, filter)inline fun View.unRegisterReceiver(receiver: BroadcastReceiver) = context.unRegisterReceiver(receiver)inline fun View.sendBroadcast(action: String) = context.sendBroadcast(action)inline fun View.sendBroadcast(intent: Intent) = context.sendBroadcast(intent)inline fun View.sendBroadcastSync(action: String) = context.sendBroadcast(action)inline fun View.sendBroadcastSync(intent: Intent) = context.sendBroadcastSync(intent)// 同上实现，对 Fragment 进行扩展inline fun Fragment.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = activity.registerReceiver(receiver, filter)inline fun Fragment.unRegisterReceiver(receiver: BroadcastReceiver) = activity.unRegisterReceiver(receiver)inline fun Fragment.sendBroadcast(action: String) = activity.sendBroadcast(action)inline fun Fragment.sendBroadcast(intent: Intent) = activity.sendBroadcast(intent)inline fun Fragment.sendBroadcastSync(action: String) = activity.sendBroadcast(action)inline fun Fragment.sendBroadcastSync(intent: Intent) = activity.sendBroadcastSync(intent)// 同上实现，对 FragmentV4 进行扩展inline fun FragmentV4.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = requireActivity().registerReceiver(receiver, filter)inline fun FragmentV4.unRegisterReceiver(receiver: BroadcastReceiver) = requireActivity().unRegisterReceiver(receiver)inline fun FragmentV4.sendBroadcast(action: String) = requireActivity().sendBroadcast(action)inline fun FragmentV4.sendBroadcast(intent: Intent) = requireActivity().sendBroadcast(intent)inline fun FragmentV4.sendBroadcastSync(action: String) = requireActivity().sendBroadcast(action)inline fun FragmentV4.sendBroadcastSync(intent: Intent) = requireActivity().sendBroadcastSync(intent)]]></content>
      <categories>
        <category>资料</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>知识点</tag>
        <tag>编程</tag>
        <tag>Broadcast</tag>
        <tag>LocalBroadcastManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava详解]]></title>
    <url>%2Fblog%2FRxJava%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这篇文章大概是2017年时整理的，一直在OneNote中存放着，如今创建了个人博客，自然拿了出来。PS：从OneNote中复制出来后格式乱码，整理的我想吐… 介绍RxJava是Java上一个灵活的、使用可观测序列组成的一个异步的、基于事件的库。 特点： 作用：异步 模式：观察者模式-本质上是基于回调 结构：响应式编程 逻辑简洁，可读性高，易维护 链式结构的执行顺序 基本流程 创建事件资源，也就是被观察者。可以用Observable.create/just/from等方法来创建。 通过filter/debounce等操作符，进行自定义事件过滤。 通过Schedules进行事件发送和订阅的线程控制，也就是subscribeOn()和observeOn()。 通过map/flatMap/compose等操作符，进行事件的变换 调用subscribe进行事件订阅。 最后，不要忘了对订阅者生命周期的控制，不用的时候，记得调用unsubscribe()，以免引发内存泄漏。 注意：未取消订阅而引起的内存泄漏。在Activtity.onDestroy()或不需要继续执行时取消订阅。CompositeSubscription， 相当于一个Subscription集合，来取消所有订阅。 示例123456CompositeSubscription list = new CompositeSubscription();list.add(subscription1);list.add(subscription2);list.add(subscription3);// 统一调用一次unsubscribe，就可以把所有的订阅都取消list.unsubscribe(); 基础知识Observer和Subscriber的关系 Observer是观察者，Subscriber也是观察者。 Subscriber是一个实现了Observer接口的抽象类，对Observer进行了部分扩展，在使用上基本没有区别。 Subscriber多了发送之前调用的onStart()和解除订阅关系的unsubscribe()方法。 在RxJava的subscribe过程中，Observer也总是会先被转换成一个Subscriber再使用。 RxJava开发过程中一般都使用Subscriber。 RxJava的事件订阅回调支持以下三种不完整定义的回调，我们可以根据当前需要，传入对应的Action，RxJava会相应的自动创建Subscriber。 observable.subscribe(onNextAction); observable.subscribe(onNextAction, onErrorAction); observable.subscribe(onNextAction, onErrorAction, onCompleteAction); 响应式编程 Observable发出一系列事件，它是事件的产生者。 Subscriber负责处理事件，它是事件的消费者。 Operator是对Observable发出的事件进行修改和变换 。 注意：若事件从产生到消费不需要其他处理，则可以省略掉中间的Operator，从而流程变为Obsevable -&gt; Subscriber。 Subscriber通常在主线程执行，所以原则上不要去处理太多的事务，而这些复杂的事务处理则交给Operator。 知识点Scheduler线程控制默认情况下，RxJava事件产生和消费均在同一个线程中，例如在主线程中调用，那么事件的产生和消费都在主线程，但RxJava可以自由切换线程。 RxJava线程调度器 Schedulers.io(); I/O操作（读写文件、数据库、网络请求等），与 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 效率比 newThread() 更高。值得注意的是，在 io() 下，不要进行大量的计算，以免产生不必要的线程。 Schedulers.newThread(); 开启新线程操作 Schedulers.immediate(); 默认指定的线程，也就是当前线程 Schedulers.computation(); 计算所使用的调度器。这个计算指的是CPU密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为CPU核数。值得注意的是不要把I/O操作放在computation()中否则I/O操作的等待时间会浪费CPU。 注意： AndroidSchedulers.mainThread();是RxJava扩展的Android主线程。 通过subscribeOn()和observeOn()这两个方法来进行线程调度。 变换操作符（重点）RxJava可以将发送的事件或事件序列，加工后转换成不用的事件或事件序列。 map操作符 是一对一的变换 返回的是变换后的对象 变换后的对象直接发到Subscriber回调中 flatMap操作符 可以适应一对多的变换 返回的是一个Observable被观察者对象 返回的Observable对象并不是直接发送到Subscriber的回调中，而是重新创建一个Observable对象，并激活这个Observable对象，使之开始发送事件 flatMap变换后产生的每一个Observable对象发送的事件，最终都汇入同一个Observable，进而发送给Subscriber回调 注意： map的返回类型与flatMap返回的Observable事件类型，可以与原来的事件类型一样 可以对一个Observable多次使用map和flatMap flatMap常常被用于嵌套的异步操作，例如：嵌套网络请求 map操作符代码示例12345678910111213141516171819202122232425262728293031323334353637final ImageView ivLogo = (ImageView) findViewById(R.id.ivLogo);Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("https://ss2.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=4db5130a073b5bb5a1d727fe06d2d523/cf1b9d16fdfaaf51965f931e885494eef11f7ad6.jpg"); &#125;&#125;).map(new Func1&lt;String, Drawable&gt;() &#123; @Override public Drawable call(String url) &#123; try &#123; Drawable drawable = Drawable.createFromStream(new URL(url).openStream(), "src"); return drawable; &#125; catch (IOException e) &#123; &#125; return null; &#125;&#125;)// 指定subscribe()所在的线程，也就是call()方法调用的线程.subscribeOn(Schedulers.io())// 指定Subscriber回调方法所在的线程，也就是onCompleted,onError,onNext回调的线程 .observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, e.toString()); &#125; @Override public void onNext(Drawable drawable) &#123; if (drawable != null) &#123; ivLogo.setImageDrawable(drawable); &#125; &#125;&#125;); flatMap操作符代码示例1234567891011121314151617181920212223242526final List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;() &#123; &#123; add(new Employee("jackson", mission_list1)); add(new Employee("sunny", mission_list2)); &#125;&#125;;Observable.from(list) .flatMap(new Func1&lt;Employee, Observable&lt;Employee.Mission&gt;&gt;() &#123; @Override public Observable&lt;Employee.Mission&gt; call(Employee employee) &#123; return Observable.from(employee.missions); &#125; &#125;) .subscribe(new Subscriber&lt;Employee.Mission&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Employee.Mission mission) &#123; Log.i(TAG, mission.desc); &#125; &#125;); from操作符接收一个集合作为输入，每次输出一个元素给subscriber 注意：若需要执行耗时操作，即使在from中使用subscribeOn(Schedulers.io())，仍然是在主线程执行，会造成界面卡顿甚至崩溃。 from操作符代码示例12345678// 格式：Observable.from(T[] params)Observable.from(new Integer[]&#123;1, 2, 3, 4, 5&#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number:" + number); &#125; &#125;); just操作符接收一个可变参数作为输入，最终也是生成数组，调用from()，每次输出一个元素给subscriber just操作符代码示例12345678// Observable.just(T... params)，params的个数为1 ~ 10Observable.just(1, 2, 3, 4, 5) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number:" + number); &#125; &#125;); filter操作符条件过滤，用于去除不符合条件的事件 filter操作符代码示例1234567891011121314Observable.from(new Integer[]&#123;1, 2, 3, 4, 5&#125;) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer number) &#123; // 偶数返回true，则表示剔除奇数，留下偶数 return number % 2 == 0; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number:" + number); &#125; &#125;); take操作符最多保留的事件数 doOnNext操作符在处理下一个事件前要做的事 take和doOnNext操作符代码示例1234567891011121314151617181920212223Observable.from(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer number) &#123; // 偶数返回true，则表示剔除奇数 return number % 2 == 0; &#125; &#125;) // 最多保留三个，也就是最后剩三个偶数 .take(3) .doOnNext(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; // 在输出偶数之前输出它的hashCode Log.i(TAG, "hahcode = " + number.hashCode() + ""); &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number = " + number); &#125; &#125;); 输出结果：1234567&gt; hahcode = 2&gt; number = 2&gt; hahcode = 4&gt; number = 4&gt; hahcode = 6&gt; number = 6&gt; debounce操作符过滤在指定的时间间隔之间的事件，接收一个事件后将在指定时间间隔后开始接收事件 debounce操作符代码示例12345678910111213141516171819202122232425262728293031323334353637383940Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; int i = 0; int[] times = new int[]&#123;100, 1000&#125;; while (true) &#123; i++; if (i &gt;= 100) break; subscriber.onNext(i); try &#123; /** 注意: 当i为奇数时，休眠1000ms，然后才发送i+1，这时i不会被过滤掉。 当i为偶数时，只休眠100ms，便发送i+1，这时i会被过滤掉 */ Thread.sleep(times[i % 2]); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; subscriber.onCompleted(); &#125;&#125;)// 间隔400ms以内的事件将被丢弃.debounce(400, TimeUnit.MILLISECONDS).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, "complete"); &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, e.toString()); &#125; @Override public void onNext(Integer integer) &#123; Log.i(TAG, "integer = " + integer); &#125;&#125;); merge操作符用于合并两个Observable为一个Observable格式： 12Observable.merge(Observable1, Observable2).subscribe(subscriber); concat操作符顺序的执行多个Ovservable，个数为1—9（示例见first操作符） compose操作符类似flatMap，都是进行变换，返回Observable对象，激活并发送事件 和flatmap区别 compose是唯一一个能从数据流中得到原始Observable的操作符，需要对整个数据流产生作用的操作需使用compose来实现。如subscribeOn()和observeOn()，在flatMap中使用的话，仅对在flatMap中创建的Observable起作用，不会对剩下的流产生影响. compose是对Observable整体的变换。flatMap转换Observable里的每一个事件，compose转换的是整个Observable数据流。 flatMap每发送一个事件都创建一个Observable，效率低。compose只在主干数据流上执行操作。 建议使用compose代替flatMap。 first操作符只发送符合条件的第一个事件。如：可以结合contact做网络三级缓存 first操作符代码示例123456789101112131415161718192021222324252627282930// 从缓存获取Observable&lt;BookList&gt; fromDisk = Observable.create(new Observable.OnSubscribe&lt;BookList&gt;() &#123; @Override public void call(Subscriber&lt;? super BookList&gt; subscriber) &#123; BookList list = getFromDisk(); if (list != null) &#123; subscriber.onNext(list); &#125; else &#123; subscriber.onCompleted(); &#125; &#125;&#125;);// 从网络获取Observable&lt;BookList&gt; fromNetWork = bookApi.getBookDetailDisscussionList();Observable.concat(fromDisk, fromNetWork)// 如果缓存不为null，则不再进行网络请求。.first().subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;BookList&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(BookList discussionList) &#123; &#125;&#125;); timer操作符定时器，可以做定时操作或延迟操作 timer操作符代码示例12345678910111213Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.i(TAG, "Hello World!"); &#125; &#125;); interval操作符定时的周期性操作，与timer操作符的区别是可以重复操作 throttleFirst操作符类似debounce操作符，时间间隔太短就会丢弃事件。可用于防抖操作，如防止双击 throttleFirst操作符代码示例1234567891011121314RxView.clicks(button) .throttleFirst(1, TimeUnit.SECONDS) .subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.i(TAG, "do clicked!"); &#125; &#125;); Single操作符相当于Observable的精简版。观察者回调的不是onNext/onError/onCompleted，而是回调onSuccess/onError subject操作符既是事件的生产者，又是事件的消费者 subject操作符代码示例1234567891011121314151617181920212223242526Subject subject = PublishSubject.create();subject.debounce(400, TimeUnit.MILLISECONDS) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; // request &#125; &#125;);edittext.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subject.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125;); 参考资料-&gt;RxJava详解-由浅入深这是当时的文章名称，如今去看作者已经进行了更新RxJava 从入门到出轨，也是骚的不行～]]></content>
      <categories>
        <category>资料</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https协议详解]]></title>
    <url>%2Fblog%2FHttps%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文内容主要讲解Https协议，其他网络知识点作为理解Https协议的辅助。 首先，需要简单知道网络协议的四个层次，即：网络接口层，网络层，传输层，应用层。 Http协议Http协议是一种超文本传输协议，是客户端浏览器与服务器之前的 应用层 通信协议。Http协议不提供数据加密，以明文的方式发送内容，容易被攻击截取信息，不适合用于传输一些敏感信息。 Https协议Https协议是以安全为目标的Http通道，在Http的基础上加入SSL层，简单来说就是Http协议的安全版。Https协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 在进行详细解释Https之前，我们需要先简单了解一些Https协议使用到的关键技术。 关键技术对称加密对称加密使用加密和解密使用相同密钥的加密算法进行加密，也叫私钥加密。常见的对称加密有：DES, AES 等。 非对称加密非对称加密与对称加密不同，使用非对称加密算法进行加密，需要两个密钥，即公钥和私钥。公钥和私钥是成对出现的，在加密和解密的过程中使用不同的密钥，所以也称为公钥加密。 数字摘要数字摘要采用单项Hash函数将需要加密的明文 _摘要_ 成一串固定长度（128位）的密文，这个密文又称为数字指纹。不同的明文摘生成的数字指纹总是不同的，而同样的明文摘要生成的数字指纹必定一致。数字摘要 是Https能确保数据完整性和防篡改的根本原因。 数字签名数字签名是对 非对称加密 和 数字摘要 两项技术的应用。它将 摘要信息 用发送者的私钥加密，与原文一起传送给接收者。接收者只有使用发送者的公钥才能解密出被加密的 摘要信息；接着对接收到的原文用 数字摘要 生成 摘要信息；然后将两个 摘要信息 进行对比。若相同，说明收到的原文是完整的，在传输过程中没有被修改。因此，数字签名能够验证数据的完整性。 SSLSSL是安全套接层，用以保障数据传输的安全，利用数据加密技术确保数据在传输过程中不会被截取。 SSL又可分为两层： SSL记录协议建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装，压缩，加密等基本功能的支持。 SSL握手协议建立在SSL记录协议之上，用于在实际的数据开始传输前，通讯双方进行身份认证，协商加密算法，交换加密密钥等。 SSL/TLS握手流程SSL/TLS握手过程流程图： 客户端发起请求：在SSL/TLS协议传输过程中，客户端和服务端必须使用同一套加解密算法才能保证数据正常的加解密。由于客户端对一些加解密算法的支持程度不一样，所以客户端需要告知服务端自己支持的加密套件的列表传给服务端。此外，客户端还要生成一个随机数（第一个随机数），用于传送给服务端，在后面的步骤中与服务端生成的随机数结合起来产生 对话密钥。 那么客户端需要提供的信息： 支持的协议版本 支持的加密算法 支持的压缩方法 随机数 服务端响应：服务端确定加密协议的版本和加密算法后，也生成一个随机数（第二个随机数），并将自己的证书一并发送给客户端。 服务端需要提供的信息： 确定支持的版本 确定加密的算法 随机数 服务器证书，包含公钥 注意：一些场景下，服务器需要确认客户端的身份，会要求客户端提供 客户端证书 客户端验证证书：客户端先对服务器下发的证书进行验证，验证通过后客户端再生成一个随机数（第三个随机数，也是最关键的随机数），并使用证书中的公钥对随机数进行加密，再加入一个 ChangeCipherSpec 即编码改变的消息和前面所有消息的Hash值，最后将所有的这些信息发送到服务器，确保在正式通信前无误。 此时，客户端得到全部的三个随机数，客户端会用协商的加密方法，生成本次会话所用的同一把 会话密钥。 ChangeCipherSpec是一个独立的协议，在数据包中就是一个字节的数据，用于告知服务端：客户端已经切换到了协商好的加密套件，准备好加密数据并进行传输了。 客户端提供的信息： 使用服务器证书中的公钥加密后的随机数（第三个） ChangeCipherSpec 编码改变的通知 握手结束的通知 注意：如果服务端需要客户端证书，客户端会在这一步发送证书信息。 服务端生成秘钥：使用私钥对随机数（第三个）的加密数据进行解密，此时服务端得到全部的三个随机数，同样使用协商的加密方法，生成和客户端使用的同一把 会话密钥。准备好后，服务端也会给客户端一个 ChangeCipherSpec 即编码改变的消息，告知客户端已经切换到了协商好的加密套件，准备好加密数据并进行传输了。 之后，服务端会使用 会话密钥 加密一段finish消息发送给客户端，以验证通过握手建立的加密通道是否成功。 客户端发送数据：确定 会话密钥 后，客户端与服务器之间就会使用对称加密加密数据后传输了。整个握手的过程也就基本完成了。 注意：SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密。因为非对称加密的速度缓慢，比较耗费资源，所以在使用非对称加密建立连接后，客户端和服务器之间传输数据使用的是协商好的对称加密算法和对称加密密钥（即会话密钥）。这个数据传输过程本身是安全可靠的，也就是说对称加密密钥是不可能被窃取盗用的。如果有人窃听通讯，他可以知道双方选择的加密方法，以及三个随机数中的两个，也就是说整个通话的安全，只取决于第三个随机数（客户端生成并加密）能不能被破解。 Session的恢复两种恢复Session对话的方式：Session ID，Session ticket。 Session ID客户端和服务器的每次对话都有一个编号。若对话中断，重连时只要客户端给出编号，并且服务器有该编号的记录，双方就可以使用已有的 对话密钥 重新建立连接，而不用重新走握手流程重新连接。 Session ID是目前所有浏览器都支持的方法，缺点是Session ID往往只保留在一台服务器上，如果客户端重连时请求发到另一台服务器上，就无法恢复对话。 Session ticket客户端发送一个服务器在上次对话中发送过来的Session ticket，其中包括对话的主要信息，如：对话密钥和加密方法等。这个Session ticket是加密的，只有服务器才能解密，服务器在解密Session ticket后就不用重新生成对话密钥了。 目前只有部分浏览器支持，如：Chrome和Firefox 参考资料： 风化成石：Https协议详解 推荐一看，文章主要精华都吸取自该博客。 施小喵：HTTPS原理解析 K__M：https协议原理]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>求职</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点-常见面试题]]></title>
    <url>%2Fblog%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文用于记录Android面试时经常遇到的问题，答案由我本人研究总结后填充，方便回忆知识点，日后面试前准备，学习交流等目的。 答案会在日后空闲时间慢慢填充 题目目录初始取材：莫少侠：18年底Android面经分享 网络基础Https原理见：Https协议详解 Http与Https的区别？TCP和UDP的区别？Http的报文结构？cookie的用处？Http有哪些响应码，都代表什么意思？ 多线程Sleep和wait的区别？Java有哪些线程池，区别是什么？线程池的工作流程和实现原理Cache线程池的缺点？多线程的通信方式synchronize关键字的用法，其他的同步方式？Thread直接调用run方法会怎么样？Start方法作用是什么？volatile关键字的作用是什么？怎么安全停止一个线程任务？原理是什么？线程池有类似的机制吗？ 数据结构HashMap和HashTable的区别？HashMap和ConcurrentHashMap的区别？HashMap和LinkedHashMap的区别？HashMap的内部实现原理LRUCache的原理ArrayList和LinkedList的区别？为什么ArrayList不是线程安全的？数据库的索引用是什么数据结构？ 虚拟机Java垃圾回收机制？有哪些对象可以作为GC roots？跟Art，Dalvik对比Java内存模型类加载机制？双亲委托模型？ Android题项目中遇到的难题或者坑做过那些性能优化？怎么评测和具体实现的Activity的冷启动流程？AMS的作用？怎么分析内存泄露？View的事件分发机制？滑动冲突如何解决？自定义View的原理和流程Handler原理Android有哪些多线程通信方式？Binder机制实现？Android的生命周期，启动模式项目中使用的开源库？实现原理？OkHttp，RxJava，Retrofit重点 Android的打包流程？apk中有哪些东西？签名算法的原理？了解哪些插件话技术LinearLayout的布局流程MVP，MVVMAndroid怎么做保活？ 算法 排序相关的（快排，分析不同排序区别，时间复杂度等） 字符串、数组相关的（滑动窗口、双指针） 链表（反转链表） 递归、斐波那契数列（爬楼梯） 动态规划 其他用过那些设计模式？DCL单例模式为什么要两次判空？Android源码中或用过的开源库用到了什么设计模式？final关键字的作用？静态内部类和内部类的区别？值传递类问题Kotlin为什么能和Java混编？]]></content>
      <categories>
        <category>资料</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>知识点</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin：作用域函数]]></title>
    <url>%2Fblog%2FKotlin%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言最近使用kotlin语言开发了新的项目，kotlin的一些特性和大量的语法糖相当好用，相比于java，开发效率高了不少。但Kotlin大量的语法糖也带来了一些问题：学习成本高，语法糖使用场景的困惑。比如，当我第一次看到作用域函数就产生了这样的疑问：what is this？Which function to use? 于是我研究了一下什么是作用域函数，以及各个函数的区别和使用场景。 介绍官方介绍：The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions. There are five of them: let, run, with, apply, and also. 翻译理解：作用域函数的目的是在对象的上下文中执行代码块，它为调用者对象提供了一个临时内部作用域，在这个作用域中可以不显式的访问该对象。这样的作用域函数有5个：let，run，with，apply，和also。 函数runrun函数是最能体现作用域的用途的函数，如下使用示例：在mian函数中使用run函数创建了一个单独的作用域，在该作用域中重新定义了一个word变量，两次打印使用的是各自作用域中的word变量，互不影响；并且，run函数返回了lambda结果。 使用示例12345678910fun main(args: Array&lt;String&gt;) &#123; var word = "我是小明" val returnValue = run &#123; var word = "我是小红" println("run:$word") word &#125; println("main:$word") println("returnValue:$returnValue")&#125; 运行结果： 123run:我是小红main:我是小明returnValue:我是小红 withwith函数可以将任意对象作为上下文对象this传入，并且可以隐式的访问该对象，返回lambda结果。如下使用示例：在mian函数中使用with函数创建了一个临时作用域，在该作用域中可以重新定义person变量，两个person变量互无影响；并且可以使用this访问上下文对象，隐式修改person的age变量值。 使用示例12345678910111213141516data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person = Person("小明",25) val returnValue = with(person) &#123; println("with:this=$this") var person = Person("小红",23) println("with:person=$person") age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234with:this=Person(name=小明, age=25)with:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.runT.run函数可以使用T作为作用域的上下文对象this，在作用域中可以隐式访问T对象，并返回lambda结果。 使用示例123456789101112131415161718192021data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null // T?.run当T为null时不调用run函数 person?.run &#123; println("person?.run:person=$person") &#125; person = Person("小明",25) val returnValue = person.run &#123; println("person.run:this=$this") var person = Person("小红",23) println("person.run:person=$person") age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.run:this=Person(name=小明, age=25)person.run:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.letT.let函数与T.run函数唯一的区别是：T作为作用域上下文对象的名称不同，前者是it，后者是this，所以在T.let函数中必须显式使用it访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null person?.let &#123; println("person?.let:person=$person") &#125; person = Person("小明",25) val returnValue = person.let &#123; println("person.let:it=$it") var person = Person("小红",23) println("person.let:person=$person") it.age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.let:it=Person(name=小明, age=25)person.let:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.also如下使用示例，T.also函数和T.let函数的唯一区别是：前者返回值是this（即T），后者返回值是lambda结果。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null person?.also &#123; println("person?.also:person=$person") &#125; person = Person("小明",25) val returnValue = person.also &#123; println("person.also:it=$it") var person = Person("小红",23) println("person.also:person=$person") it.age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.also:it=Person(name=小明, age=25)person.also:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) T.apply如下使用示例，T.apply函数和T.also函数的唯一的区别是：T作为作用域上下文对象的名称不同，前者是this，后者是it，所以在T.apply函数中可以隐式访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null person?.apply &#123; println("person?.apply:person=$person") &#125; person = Person("小明",25) val returnValue = person.apply &#123; println("person.apply:this=$this") var person = Person("小红",23) println("person.apply:person=$person") age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.apply:this=Person(name=小明, age=25)person.apply:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) 特殊的作用域函数T.takeIf以it作为在作用域上下文对象T的名称，若lambda结果为true，返回this；否则，返回null。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin("1.1")public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? &#123; contract &#123; callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) &#125; return if (predicate(this)) this else null&#125; 使用示例123456789fun main(args: Array&lt;String&gt;) &#123; var count = 0 while (count &lt;= 10) &#123; val returnValue = count.takeIf &#123; count++ % 2 == 0 &#125; println(returnValue) &#125;&#125; 运行结果： 12345678910110null2null4null6null8null10 T.takeUnless以it作为在作用域上下文对象T的名称，若lambda结果为true，返回null；否则，返回this。与taskIf的实现相比，其实就是对lambda结果进行了取反操作。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin("1.1")public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? &#123; contract &#123; callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) &#125; return if (!predicate(this)) this else null&#125; 使用示例123456789fun main(args: Array&lt;String&gt;) &#123; var count = 0 while (count &lt;= 10) &#123; val returnValue = count.takeUnless &#123; count++ % 2 == 0 &#125; println(returnValue) &#125;&#125; 运行结果： 1234567891011null1null3null5null7null9null repeat以当前执行的次数it作为在作用域上下文对象T的名称，执行给定lambda函数指定的次数。从函数源码和使用示例可以看出，执行次数角标是从0开始。 函数源码1234567@kotlin.internal.InlineOnlypublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) &#123; contract &#123; callsInPlace(action) &#125; for (index in 0 until times) &#123; action(index) &#125;&#125; 使用示例12345fun main(args: Array&lt;String&gt;) &#123; repeat(5) &#123; print("$it,") &#125;&#125; 运行结果： 10,1,2,3,4, 总结从上面的函数介绍和实际使用可以看出let，run，with，apply，和also，这些作用域函数的功能之间起着相互补充的作用，单独看某两个函数可能差别不大，但它们结合起来所实现的功能涵盖了绝大部分的使用场景。 总结一下，用于快速判断操作符使用场景，主要使用这几个因素辨别： 调用者： 正常函数：有run，with函数。主要作用是：开辟一个作用域，不受作用域之外上下文影响，with还可以方便地在作用域中访问上下文对象。 扩展函数：可以使用T?.fun()在调用之前做空检查，如：null?.run { println(&quot;Kotlin&quot;) }，作用域内容不会被执行。 上下文对象 this：方便在作用域中直接访问this it：可以更清楚的区分作用域和非作用域中的成员 返回值 上下文对象this：可以作为链式调用。 lambda表达式结果：返回表达式结果，可以将结果结合其他作用域函数，使用更灵活。 12345678910// 示例：使用apply函数进行链式调用class Person &#123; var name = "" var age = 0&#125;fun main(args: Array&lt;String&gt;) &#123; val person = Person().apply &#123; name = "小明" &#125;.apply &#123; age = 25 &#125; println("$&#123;person.name&#125;,$&#123;person.age&#125;")&#125;// 运行结果：小明,25 下面对作用域函数简要区分，可以更方便快速的辨别各函数的作用和使用场景。 作用域函数简要区分： run：返回lambda结果 with：this上下文，返回lambda结果 T.run：支持空检查，this上下文，返回lambda结果 T.let：支持空检查，it上下文，返回lambda结果 T.also：支持空检查，it上下文，返回this（即T，it） T.apply：支持空检查，this上下文，返回this（即T，this） 特殊的作用域函数区分： T.takeIf：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回this；否则返回null T.takeUnless：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回null；否则返回this repeat：执行给定函数 action 指定的次数 times （角标：0-times） 参考资料 官方文档：https://www.kotlincn.net/docs/reference/scope-functions.htmlmedium Elye：https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84CSDN george_zyf：https://blog.csdn.net/android_zyf/article/details/82496983]]></content>
      <categories>
        <category>资料</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>编程</tag>
        <tag>run</tag>
        <tag>with</tag>
        <tag>let</tag>
        <tag>also</tag>
        <tag>apply</tag>
        <tag>takeIf</tag>
        <tag>takeUnless</tag>
        <tag>repeat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins持续集成]]></title>
    <url>%2Fblog%2FJenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[安装Jenkins使用可执行安装文件下载安装Jenkins官网下载对应平台的安装文件 Mac下载的是pkg格式安装包 此种方式安装，会在Mac系统里创建一个名为jenkins用户，Jenkins服务就部署在这个用户下 Widows下载的是zip格式的压缩文件，解压后得到exe格式安装包 使用war安装Jenkins官网选择war文件下载 打开终端，进入war文件所在的目录 执行下面命令：java -jar jenkins.war --httpPort=8080 war包自带jetty服务器，执行命令后会启动服务器，并完成部署。 不推荐该方式安装：安装后会在用户的根路径生成.jenkins隐藏文件，并产生多余的配置文件，需要手动管理，并不便卸载。 Mac下使用Homebrew安装 安装Homebrew 自行官网搜索安装方式 安装，命令行执行：brew install jenkins 卸载，命令行执行：brew uninstall jenkins Homebrew会下载，并自动完成所有依赖，包括java。并创建jenkins命令推荐使用该方式安装，不会在系统中产生垃圾文件和多余的配置文件，生成的所有文件都由Homebrew进行管理，方便卸载。 Jenkins常用命令命令行方式 启动服务：brew services start jenkins 该方式启动jenkins服务，在后台运行，终端关闭无影响。 重启服务：brew services restart jenkins 停止服务：brew services stop jenkins 浏览器地址 重载服务：http://localhost:8080/reload 重启服务：http://localhost:8080/restart 停止服务：http://localhost:8080/exit 配置Jenkins创建用户 安装并启动Jenkins服务后，在浏览器中打开http://localhost:8080/，进入配置jenkins页面。 根据提示，打开~/.jenkins/secrets/initialAdminPassword文件，复制密码并填入，点击继续进入安装插件页面。 建议选择，安装推荐的插件。等待插件安装完成后，Jenkins服务会重启，待重启完成后，会进入创建用户页面。 在创建用户页面，填写用户信息后保存。 安装插件除了首次进入Jenkins时安装的推荐插件，还要安装一些必备插件。 Android自动化构建必备插件 Gradle Plugin Gitlab Plugin]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>软件</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS系统安装必备软件和搭建开发环境]]></title>
    <url>%2Fblog%2FmacOS%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6%E5%92%8C%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[由于个人喜欢折腾系统和软件，一段时间后总觉得系统会残留很多的垃圾文件，每到这时总控制不住自己去清空数据后重装系统。所以做下记录，方便在重装系统后快速恢复工作环境。另外，推荐一些常用软件和平常发现的一些比较好用的软件。 必备软件 ntfs for mac SSR客户端 Chrome 主题：Just Black，Oceanic，Slate，Material Incognito Dark Theme 插件：Axure RP，Adblock Plus，Json Formatter QQ 微信 IINA视频播放器 OneDrive Keka Folx Pdf Expert（Pdf文件阅读编辑） Contexts（窗口切换管理） Quiver（代码库） Swivik for Mac（快捷切换应用） Visual Studio Code及必备插件 Chinese (Simplified) Language Pack for Visual Studio Code Markdown All in One markdownlint（检查markdown语法） Mardwodn PDF（转换为pdf，html，png或jpeg文件） Code Runner vscode-pdf 命令行工具 Homebrew：/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; nano：brew install nano autojump： 第一步：brew install autojump 第二步 git clone https://github.com/wting/autojump.git ./autojump/install.py fish：brew install fish 若安装了autojump，配置fish： touch ~/.config/fish/config.fish 输入下方代码后保存 source ~/.config/fish/config.fish 注意 autojump.fish 文件是通过clone后执行install.py文件生成的 123456begin set --local AUTOJUMP_PATH $HOME/.autojump/share/autojump/autojump.fish if test -e $AUTOJUMP_PATH source $AUTOJUMP_PATH endend 搭建开发环境jdk1.8 下载安装：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 关闭自动更新 配置环境变量：nano ~/.bash_profile 注意jdk版本路径 配置Visual Studio Code的settings.json 12345# Javaexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Homeexport PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/binexport PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/lib/tools.jarexport PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/lib/dt.jar 123&#123; "java.home": "/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home"&#125; Git brew安装：brew install git SSH： 全局设置用户名：git config --global user.name &quot;wangwh&quot; 全局设置邮箱：git config --global user.email &quot;wenhui.wang@gymchina.com&quot; 生成密钥：ssh-keygen -t rsa -C &quot;wenhui.wang@gymchina.com&quot; 密钥保存在：～/.ssh/文件夹中 添加密钥：ssh-add id_ras 若添加密钥出现错误：Could not open a connection to your authentication agent，执行：ssh-agent bash 在git服务器上添加公钥 Android 下载安装ideaIC 配置Android Sdk环境变量 12345# Androidexport ANDROID_HOME=~/Documents/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/tools/bin 安装必备插件 GenerateSerialVersionUID Parcelable Code Generator(for kotlin) JSON To Kotlin Class (JsonToKotlinClass) Anko Support Json Parser Flutter 下载Flutter 将Flutter解压 配置Flutter环境变量 Visual Studio Code插件 Flutter（安装时会依赖安装Dart） Android iOS Emulator 配置sdk路径：Setting - User Setting - Extensions - Emulator：~/Documents/Android/sdk/emulator 命令行检查环境是否配置成功：flutter doctor，然后根据错误提示进行操作 使用ideaIC创建Android模拟器 123456# Flutterexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport FLUTTER_HOME=~/Documents/Flutter/flutterexport PATH=$&#123;PATH&#125;:$&#123;FLUTTER_HOME&#125;/binexport PATH="$PWD/flutter/bin:$PATH"]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>软件</tag>
        <tag>系统</tag>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2Fblog%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这遍笔记最早可以追溯到2015年，已记不清是怎么了解到的Markdown。当时就被Markdown可以直接转换为html的特性震惊了，随后立即学习了一下Markdown的语法，并随手作为练习语法将之记录了下来。不过由于当时使用了印象笔记记录信息，只用Markdown写了几次后，就没有再使用过，现在重新捡了起来，真香～ 标题的使用 最多6级标题 一级标题二级标题三级标题四级标题五级标题六级列表列表无序列表 可以使用 - + * 列表中可以加入其他语法，如：标题 1 2 3 4 5 6 有序列表 1 2 加入其他语法 区块引用 This is a blockquote.inside a list item. 代码区块 行内代码 代码块 使用区块引用 可以只在段落第一行加 &gt; 区块引用可以嵌套 区块引用内可以加入其他语法这是一个标题。 这是第一行列表项。 这是第二行列表项。给出一些例子代码：行内代码 插入链接行内链接 格式：[链接上的文字](http://example.com &quot;标题&quot;) 这是 Google 官网 参考式链接（定义链接内容） 格式：[链接标识]: http://example.com/ &quot;标题&quot; 引用参考式链接：这是 MSN 官网 隐式链接标记功能步骤： 简化参考式链接：bing 等同于 bing 定义链接内容：bing: http://bing.com/ 引用隐式链接：这是bing官网 自动链接 链接文字和链接地址相同 http://example.com/ &#97;&#100;&#100;&#x72;&#101;&#x73;&#115;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#46;&#99;&#111;&#x6d; 插入图片 强调：粗体和斜体 使用 * 和 _ 两个符号强调字词，单个符号表示斜体，两个相同符号表示粗体 粗体这是一段粗体文字 这是一段粗体文字 斜体这是一段斜体文字 这是一段斜体文字 表格 冒号表示对齐方式 编号 姓名 年龄 001 小泽 21 002 小苍 22 003 小呆 20 代码框的使用方式 行内代码：使用两个 `(反引号) 把中间的代码包裹起来 代码块：使用Tab键 123public void main () &#123; System.out.println("Hello Markdown");&#125; 用多个反引号插入反引号：There is a literal backtick (`) here. 分割线的使用使用3个或以上的 * - 符号建立分割线（中间可以有空格) 反斜杠转义字符：\支持以下字符： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>资料</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+Coding搭建个人博客]]></title>
    <url>%2Fblog%2FHexo-Github-Coding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[# 前言两年前，我就产生过搭建个人博客的想法，但在了解到搭建博客需要购买服务器，域名，配置博客平台等，发现需要投入的精力太大，之后因为工作繁忙等原因，搭建个人博客的事就不了了之了。 由于近期工作节奏较慢，想梳理和扩展下自己的知识面，同时给自己一个压力，让自己处于积极向上的状态，终于开始了个人博客的搭建。 在网上搜索后，发现有一种方式可以绕过个人服务器搭建博客，减少了一些精力和成本，而且能很好地满足我的个人需求，那就是Hexo+Github+Coding。 Github大家都知道，是目前全球最大的男性同性交友平台。开个玩笑，不在多述。Coding是腾讯开发者代码托管平台，相比Github平台的优点是可以免费创建私人仓库，并提供了pages服务，是我们实现个人博客的基础。 下面主要说下Hexo。 HexoHexo 搭建步骤 获取个人域名 安装Git 安装nodejs 安装Hexo 注册Github，并创建个人仓库 注册Coding，并创建私人仓库 推送网站 更换主题 发布文章 个性化设置 其他 由于我使用的是Mac笔记本，所以下面的搭建步骤只适合Mac环境 个人域名 域名是我网站的入口，常见的有com，cn，net，org等后缀，可以根据自己的喜好选择后缀。推荐购买国内万网的域名，我选择的是site后缀，相对而言非常便宜了，10年179RMB。 安装Git安装NodeJS建议在官网Node下载安装包进行安装，会包含环境变量和npm的安装，安装后检测node和npm是否安装成功 12node -vnpm -v 安装Hexo1npm install hexo-cli -g Setup your blog 12hexo init blogcd blog Start the server 1hexo server Create a new post 1hexo new "Hello Hexo" Generate static files 1hexo generate Github注册Github 新建仓库 Coding注册Coding 新建仓库 推送网站更换主题发布文章个性化设置其他 未完待续，敬请期待]]></content>
      <categories>
        <category>工具</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>Hexo</tag>
        <tag>Next主题</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
