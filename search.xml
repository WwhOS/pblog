<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode-算法题-简单-01]]></title>
    <url>%2Fblog%2FLeetCode-%E7%AE%97%E6%B3%95%E9%A2%98-%E7%AE%80%E5%8D%95-01%2F</url>
    <content type="text"><![CDATA[LeetCode简单算法题：1～205 LeetCode官网地址 1 两数之和（2019.03.26）记得面试时是被问到过这个题的，但当时被前面的面试题搞的有些发懵，理解错了“不能重复利用这个数组中同样的元素”这句话的含义，实在惭愧，再看到这道题时一时感慨万千。 问题描述给定一个整数数组 nums 和一个目标值 target ，请你在该数组中找出和为目标值的那 两个整数 ，并返回他们的 数组下标 。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答过程首先分析下问题： 参数：数组 nums 是一个无序整数数组，元素可重复；target 是一个整数 需求：target是数组中两个元素的和；数组中必有也只有两个元素能满足条件；不能重复利用两个数组中同样的元素 结果：满足需求的两个元素的下标 疑问：未能理解 不能重复利用两个数组中同样的元素 这个要求 思路：两个循环嵌套找出所需元素，返回下标 虽然下面的两次代码都通过了测试，但是没有满足 不能重复利用两个数组中同样的元素 这个条件。带着疑问我们看了标准答案，发现也是正确答案，不过是占用资源最多的解法，最优解思路确实很妙。 12345678910111213141516/** * 执行用时 : 55 ms, 在Two Sum的Java提交中击败了31.73% 的用户 * 内存消耗 : 40.3 MB, 在Two Sum的Java提交中击败了0.99% 的用户 */class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int x = 0;x &lt; nums.length - 1;x++) &#123; for (int y = x + 1;y &lt; nums.length;y++) &#123; if ((nums[x] + nums[y]) == target) &#123; return new int[] &#123;x, y&#125;; &#125; &#125; &#125; return null; &#125;&#125; 1234567891011121314151617/** * 执行用时 : 49 ms, 在Two Sum的Java提交中击败了37.38% 的用户 * 内存消耗 : 37.8 MB, 在Two Sum的Java提交中击败了0.99% 的用户 */class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int y; // 相比上个解法只是减少了y的创建 for (int x = 0;x &lt; nums.length - 1;x++) &#123; for (y = x + 1;y &lt; nums.length;y++) &#123; if ((nums[x] + nums[y]) == target) &#123; return new int[] &#123;x, y&#125;; &#125; &#125; &#125; return null; &#125;&#125; 标准答案暴力法12345678910public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 两遍哈希表该方法利用了HashMap#containsKey函数，大幅提升了执行效率。 资源占用：执行用时 : 12 ms, 在Two Sum的Java提交中击败了68.76% 的用户内存消耗 : 38.7 MB, 在Two Sum的Java提交中击败了0.99% 的用户 12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 一遍哈希表该方法也是利用了HashMap实现，但是原理与两遍哈希表的解法不同，通过将遍历过的元素和元素下标缓存起来，在下个循环判断缓存中是否有本循环元素相加等于目标值，有则返回。妙！ 资源占用：执行用时 : 11 ms, 在Two Sum的Java提交中击败了73.97% 的用户内存消耗 : 41.2 MB, 在Two Sum的Java提交中击败了0.99% 的用户 1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution");&#125; 7 整数反转（2019.03.27）问题描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解答过程首先分析下问题： 参数：有符号整数 需求：将数字进行反转 结果：返回反转后的整数 思路： 将整数转化为字符串，取出负数符号 循环字符重新排列 将负数符号和重新排列后的字符进行组合 将组合后的字符串转化为整数 返回整数 123456789101112131415161718192021/** * 执行用时 : 45 ms, 在Reverse Integer的Java提交中击败了48.85% 的用户 * 内存消耗 : 48.5 MB, 在Reverse Integer的Java提交中击败了0.95% 的用户 */class Solution &#123; public int reverse(int x) &#123; String xStr = String.valueOf(Math.abs(x)); StringBuilder xrSb = new StringBuilder(); char[] xCharArray = xStr.toCharArray(); for (int i = xCharArray.length - 1;i &gt;= 0;i--) &#123; xrSb.append(xCharArray[i]); &#125; try &#123; int result = Integer.parseInt(xrSb.toString()); return x &gt; 0 ? result : -result; &#125; catch (Exception e) &#123; &#125; return 0; &#125;&#125; 标准答案弹出和推入数字 &amp; 溢出前进行检查 思路我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。 算法请原谅我才疏学浅并没有看懂详解。附上链接：整数反转-题解 12345678910111213class Solution &#123; public int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; &#125; return rev; &#125;&#125; 9 回文数（2019.05.15）问题描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。进阶：你能不将整数转为字符串来解决这个问题吗？ 示例1： 12输入: 121输出: true 示例2： 12输入: -121输出: false 问题分析 参数：整数，有符号 需求：判断是否是回文数 结果：返回结果 思路-1： 将整数转化为字符串 循环字符进行倒序排列，得到倒序字符串 比较参数字符串和倒序后的字符串是否相同 返回比较结果 我的答案12345678910111213141516/** * 执行用时 : 50 ms, 在Palindrome Number的Java提交中击败了84.03% 的用户 * 内存消耗 : 36 MB, 在Palindrome Number的Java提交中击败了97.33% 的用户 */class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; String xStr = String.valueOf(x); StringBuilder xrSb = new StringBuilder(); char[] xCharArray = xStr.toCharArray(); for (int i = xCharArray.length - 1;i &gt;= 0;i--) &#123; xrSb.append(xCharArray[i]); &#125; return xStr.equals(xrSb.toString()); &#125;&#125; 官方题解1234567891011121314151617181920212223public class Solution &#123; public bool IsPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber/10; &#125;&#125; 为了更好的理解，我执行了下面的代码进行分析： 12345678910111213141516171819202122232425262728class Test &#123; public static void main(String[] args) &#123; isPalindrome(121); isPalindrome(-121); isPalindrome(9); isPalindrome(12321); &#125; public static boolean isPalindrome(int x) &#123; System.out.println("------------------"); System.out.println("参数：" + x); boolean result = true; if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; result = false; &#125; else &#123; int revertedNumber = 0; while (x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; System.out.println("x=" + x + "; num=" + revertedNumber); &#125; result = x == revertedNumber || x == revertedNumber / 10; &#125; System.out.println("结果：" + result); return result; &#125;&#125; 输出结果： 123456789101112131415161718------------------参数：121x=12; num=1x=1; num=12结果：true------------------参数：-121结果：false------------------参数：9x=0; num=9结果：true------------------参数：12321x=1232; num=1x=123; num=12x=12; num=123结果：true 13 罗马数字转整数（2019.05.15）问题描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例： 输入 输出 III 3 IV 4 IX 9 LVIII 58 MCMXCIV 1994 问题分析刚看到这个问题时感觉比较棘手，实际分析后发现并没有那么复杂，难的是算法最优解。 字符和数值是一对一的关系 有6种特殊字符表示其他的数值 各个字符对应的数值相加，可以得到最终值 我的答案答案一思路： 首先要建立一个字符和数值的对应表，特殊字符和数值对应表 遍历字符串，先取两个一组的字符判断是否是特殊字符，不是的话取单个字符对应的数值 对所有的数值进行累加，得到最终值 返回最终值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 执行用时 : 33 ms, 在Roman to Integer的Java提交中击败了71.16% 的用户 * 内存消耗 : 42.7 MB, 在Roman to Integer的Java提交中击败了67.73% 的用户 */class Solution &#123; // 两个Map减少循环次数 private static Map&lt;String, Integer&gt; romanArray = new HashMap&lt;String, Integer&gt;(); private static Map&lt;String, Integer&gt; romanArray2 = new HashMap&lt;String, Integer&gt;(); static &#123; romanArray.put("I", 1); romanArray.put("V", 5); romanArray.put("X", 10); romanArray.put("L", 50); romanArray.put("C", 100); romanArray.put("D", 500); romanArray.put("M", 1000); romanArray2.put("IV", 4); romanArray2.put("IX", 9); romanArray2.put("XL", 40); romanArray2.put("XC", 90); romanArray2.put("CD", 400); romanArray2.put("CM", 900); &#125; public int romanToInt(String s) &#123; int result = 0; String tmpStr; Integer tmpVal; for (int i = 0; i &lt; s.length();) &#123; String startStr = String.valueOf(s.charAt(i)); if (i + 1 &lt; s.length()) &#123; tmpStr = startStr + String.valueOf(s.charAt(i + 1)); tmpVal = romanArray2.get(tmpStr); if (tmpVal == null) &#123; tmpStr = startStr; tmpVal = romanArray.get(tmpStr); &#125; &#125; else &#123; tmpStr = startStr; tmpVal = romanArray.get(tmpStr); &#125; result += tmpVal.intValue(); i += tmpStr.length(); &#125; return result; &#125;&#125; 答案二上面的代码提交后虽然通过了，但是代码看起来着实不太优雅，对效率和资源占用不太满意，随之做出了下面的修改 12345678910111213141516171819202122232425262728293031323334/** * 执行用时 : 执行用时 : 20 ms, 在Roman to Integer的Java提交中击败了96.95% 的用户 * 内存消耗 : 内存消耗 : 35.8 MB, 在Roman to Integer的Java提交中击败了99.61% 的用户 */class Solution &#123; private static Map&lt;String, Integer&gt; romanArray = new HashMap&lt;String, Integer&gt;(); static &#123; romanArray.put("I", 1); romanArray.put("V", 5); romanArray.put("X", 10); romanArray.put("L", 50); romanArray.put("C", 100); romanArray.put("D", 500); romanArray.put("M", 1000); &#125; public int romanToInt(String s) &#123; int result = 0; for (int i = 0; i &lt; s.length();i++) &#123; int val1 = romanArray.get(String.valueOf(s.charAt(i))); if (i &lt; s.length() - 1) &#123; int val2 = romanArray.get(String.valueOf(s.charAt(i + 1))); if (val1 &lt; val2) &#123; result += (val2 - val1); i++; continue; &#125; &#125; result += val1; &#125; return result; &#125;&#125; 14 最长公共前缀这个问题给我的启发很大，分治和问题变体部分扩展了我解决某些问题的思路，应着重看下。 问题描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串””。说明：所有输入只包含小写字母a-z。 我的解答根据最小长度的元素，使用二分查找法截取元素字符，再拿截取的字符串去遍历数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 执行用时 : 288 ms, 在所有 Kotlin 提交中击败了69.35%的用户 * 内存消耗 : 34.6 MB, 在所有 Kotlin 提交中击败了88.24%的用户 */ class Solution &#123; fun longestCommonPrefix(strs: Array&lt;String&gt;): String &#123; if (strs.isNullOrEmpty()) return "" val shortestEl = findShortestEl(strs) if (shortestEl.isEmpty()) return "" if (checkCommonPrefix(strs, shortestEl)) return shortestEl var commonPrefix = "" var minPosition = 0 var maxPosition = shortestEl.length var position = getPosition(minPosition, maxPosition) while (position != -1) &#123; val prefix = shortestEl.substring(0, position) if (checkCommonPrefix(strs, prefix)) &#123; commonPrefix = prefix minPosition = position &#125; else &#123; maxPosition = position &#125; val tmpPosition = getPosition(minPosition, maxPosition) if (position != tmpPosition) &#123; position = tmpPosition &#125; else &#123; break &#125; &#125; return commonPrefix &#125; private fun findShortestEl(strs: Array&lt;String&gt;): String &#123; var shortestEl = strs[0] strs.forEach &#123; if (it.length &lt; shortestEl.length) &#123; shortestEl = it &#125; &#125; return shortestEl &#125; private fun getPosition(min: Int, max: Int): Int &#123; if (min &gt;= max) return -1 var diff = max - min return min + diff / 2 + diff % 2 &#125; private fun checkCommonPrefix(strs: Array&lt;String&gt;, prefix: String): Boolean &#123; strs.forEach &#123; if (!it.startsWith(prefix)) &#123; return false &#125; &#125; return true &#125;&#125; 提交后，发现执行用时有些高，想了下，我的解法在参数数组越长执行用时可能就越长。所以在解答该题时，越少遍历数组效率越高。不过看了下官方题解，发现二分查找也是其中的一个解法。 官方题解官方给出了四种解法，下面依次来看。这里只给出解题思路，具体实现代码可在官方题解找到。 水平扫描法随机取一个元素，遍历数组元素，将其取出的元素依次从尾部减去一个字符，与其他数组元素进行比较。最坏的情况下，需要进行（（取出的元素字符数 - 1） * （数组长度 - 1））次比较. 水平扫描随机取一个元素，从前往后枚举这个元素字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。 分治使用分治技巧，将原问题分成两个子问题（left，right），再将每个子问题分成两个子问题，直到不能分出子问题。在子问题中获取公共前缀，从头到尾挨个比较left和right，最终得到原问题的解。 懒得画图了，凑合看吧～～闪～～过程：原问题：[“leetcode”,”leetcod”,”leetco”,”leetc”,”leet”,”lee”,”le”,”l”]子问题：[“leetcode”,”leetcod”,”leetco”,”leetc”]和[“leet”,”lee”,”le”,”l”]子问题：[“leetcode”,”leetcod”]、[“leetco”,”leetc”]和[“leet”,”lee”],[“le”,”l”]子结果：”leetcod”、”leetc”和”lee”、”l”子问题：[“leetcod”,”leetc”]和[“lee”,”l”]子结果：”leetc”和”l”子问题：[“leetcod”,”l”]原问题结果=子问题结果=”l” 二分查找法取出一个元素，将元素字符从前到后分成两部分，每次都用前一部分字符去匹配，如果不能匹配说明答案在前一部分中，能匹配说明答案在后一部分（加上前一部分），再对匹配到的这一部分执行同样的流程，最终得到公共前缀。 过程：数组：[“leetcode”,”leetco”,”leetc”,”leet”,”lees”]取出元素：”leetcode”匹配区间：”leetcode”不能匹配匹配区间：”leet”不能匹配匹配区间：”le”能匹配匹配区间：”lee”能匹配得到答案-&gt;”lee” 问题变体原文地址 问题描述给定一些字符串数组Array，我们要找到字符串S与Array中元素的最长公共前缀。这样的查询操作可能会非常频繁。 官方解答将所有的字符（数组中所有元素的字符）存储到字典树中来优化最长公共前缀查询操作。在字典树中，从根向下的每一个节点都代表一些元素的公共前缀。要找到字符串S与Array中元素的最长公共前缀，需要从根开始找到一条最深的路径，满足以下条件： 这是所查询的字符串S的一个前缀. 路径上的每一个子节点都有且只有一个孩子。否则，找到的路径就不是所有字符串的公共前缀。 路径不包含任一元素字符串结尾代表的节点。因为最长公共前缀不可能比任意一个字符串长。 20 有效的括号21 合并两个有序链表26 删除排序数组中的重复项27 移除元素28 实现strStr()35 搜索插入位置38 报数53 最大子序和58 最后一个单词的长度66 加一67 二进制求和69 x 的平方根70 爬楼梯83 删除排序链表中的重复元素88 合并两个有序数组100 相同的树101 对称二叉树104 二叉树的最大深度107 二叉树的层次遍历 II108 将有序数组转换为二叉搜索树110 平衡二叉树111 二叉树的最小深度112 路径总和118 杨辉三角119 杨辉三角 II121 买卖股票的最佳时机122 买卖股票的最佳时机 II125 验证回文串136 只出现一次的数字141 环形链表155 最小栈160 相交链表167 两数之和 II - 输入有序数组168 Excel表列名称169 求众数171 Excel表列序号172 阶乘后的零189 旋转数组190 颠倒二进制位191 位1的个数198 打家劫舍202 快乐数203 移除链表元素204 计数质数205 同构字符串]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>求职</tag>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-算法题-简单-05]]></title>
    <url>%2Fblog%2FLeetCode-%E7%AE%97%E6%B3%95%E9%A2%98-%E7%AE%80%E5%8D%95-05%2F</url>
    <content type="text"><![CDATA[LeetCode简单算法题：860～1013 LeetCode官网地址 闹了个乌龙，打算每篇博客50到题，从简单算法题第一道往后一道道刷的，结果不知怎的从第五页开始了。。。 so，这篇博客就先做了一道放在了这里，立个flag，看看刷到这里需要多久～ 期待我尽早刷到这里吧，哈哈 860 柠檬水找零问题描述在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 解答过程（2019.03.25）这是我最开始提交的Java实现，结果提交后发现错了，梳理了几遍后依旧没有头绪。迫不得已点击了答案，发现把该问题想简单了：顾客支付的钱只有固定的5，10，20三种，只需要梳理三种支付方式可能出现的情况，就能正确解答。 123456789101112131415161718class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; if (bills == null || bills.length &lt;= 0) return false; int change = 0; int diff = 0; for (int bill : bills) &#123; diff = bill - 5; if (diff == 0) &#123; change += bill;//这里bill等于5 &#125; else if (diff &gt; 0 &amp;&amp; change &gt;= diff) &#123; change = change - diff + bill; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125; 标准答案思路最初，没有5美元和10美元的钞票，收到20美元的钞票后，该20美元不能用于找零。 顾客支付5美元钞票，得到一张5美元的钞票 顾客支付10美元钞票 有5美元钞票，找零 没有5美元钞票，无法找零，返回false 顾客支付20美元钞票 有5美元和10美元钞票，用一张10美元和5美元钞票找零更有利于以后找零 只有5美元钞票，用三张5美元进行找零 其他情况，无法找零。 只有20美元钞票 只有10美元钞票 没有钞票 代码实现123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; // 定义局部变量记录5美元和10美元钞票的数量 int five = 0, ten = 0; for (int bill: bills) &#123; // @1 第一种情况 if (bill == 5) five++; // @2 第二种情况 else if (bill == 10) &#123; if (five == 0) return false; five--; ten++; &#125; // @3 第三种情况 else &#123; // @3.1 第三种情况的第一种可能 if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123; five--; ten--; &#125; // @3.2 第三种情况的第二种可能 else if (five &gt;= 3) &#123; five -= 3; &#125; // @3.3 第三种情况的第三种可能 else &#123; // 无法找零 return false; &#125; &#125; &#125; // 能找零 return true; &#125;&#125; 867 转置矩阵868 二进制间距872 叶子相似的树874 模拟行走机器人876 链表的中间结点883 三维形体投影面积884 两句话中的不常见单词888 公平的糖果交换892 三维形体的表面积893 特殊等价字符串组896 单调数列897 递增顺序查找树905 按奇偶排序数组908 最小差值 I914 卡牌分组917 仅仅反转字母922 按奇偶排序数组 II925 长按键入929 独特的电子邮件地址933 最近的请求次数937 重新排列日志文件941 有效的山脉数组942 增减字符串匹配944 删列造序949 给定数字能组成的最大时间953 验证外星语词典961 重复 N 次的元素965 单值二叉树970 强整数976 三角形的最大周长977 有序数组的平方985 查询后的偶数和989 数组形式的整数加法993 二叉树的堂兄弟节点994 腐烂的橘子997 找到小镇的法官999 车的可用捕获量1002 查找常用字符1005 K 次取反后最大化的数组和1012 十进制整数的反码1013 总持续时间可被 60 整除的歌曲]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>求职</tag>
        <tag>编程</tag>
        <tag>学习</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作随身移动系统]]></title>
    <url>%2Fblog%2F%E5%88%B6%E4%BD%9C%E9%9A%8F%E8%BA%AB%E7%A7%BB%E5%8A%A8%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[计划内容，内容待补充]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>软件</tag>
        <tag>系统</tag>
        <tag>硬件</tag>
        <tag>WinToUSB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你认识LocalBroadcastManager]]></title>
    <url>%2Fblog%2F%E5%B8%A6%E4%BD%A0%E8%AE%A4%E8%AF%86LocalBroadcastManager%2F</url>
    <content type="text"><![CDATA[前言我们在Android应尽量避免使用隐式Intent广播传递信息，为什么这么说？原因有下面几点： 意外接收：如果同时维护几个项目，不同项目中难免会存在代码复用的情况，这时若安装了两个注册过同样 Action 广播的APP，一个APP通过Context.sendBroadcast()发送的隐式广播也会被另一个APP接收到，并进行相应的操作，可能会产生意想不到的风险。 敏感信息外泄：发送的隐式广播，可能会被恶意应用注册监听该广播的 receiver 获取到Intent中传递的敏感信息，并进行其他危险的操作。 Intent拦截：如果发送的广播为使用Context.sendOrderedBroadcast()方法发送的有序广播，优先级较高的恶意 receiver 若直接丢弃该广播，会导致服务无法正常使用，或者广播结果被填充恶意数据。 基于以上的几点，会发现使用隐式Intent广播风险很高，那么怎么解决这个问题呢？首先，我们需要明确广播是否仅限于应用内使用。若需要在应用间传递广播，应尽量避免传递敏感信息；否则，可以使用LocalBroadcastManager.sendBroadcast()实现，这样就避免了意外接收广播，敏感信息外泄和Intent拦截的风险。 LocalBroadcastManager源码分析LocalBroadcastManager的源码并不多，总共也就不到300行，我们来分析下是怎么它的实现。 单例模式首先，从下面这几行代码会发现LocalBroadcastManager使用了延迟加载的单例模式保证类对象的唯一性。 123456789@NonNullpublic static LocalBroadcastManager getInstance(@NonNull Context context) &#123; synchronized(mLock) &#123; if (mInstance == null) &#123; mInstance = new LocalBroadcastManager(context.getApplicationContext()); &#125; return mInstance; &#125;&#125; 内部类再看LocalBroadcastManager的两个静态内部类。 123456789private static final class ReceiverRecord &#123; final IntentFilter filter; final BroadcastReceiver receiver; // 请自行分析这两个变量的作用 boolean broadcasting; boolean dead; // 省略了构造函数 // 省略了toString函数&#125; 12345private static final class BroadcastRecord &#123; final Intent intent; final ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt; receivers; // 省略了构造函数&#125; ReceiverRecord类记录了Intent过滤器和BroadcastReceiver对象，BroadcastRecord记录了发送的Intent和一个ReceiverRecord的集合，这个集合是用来做什么的呢？目前猜测存放的应该是需要接收Intent的所有BroadcastReceiver对象，带着这个疑问继续看它的关键成员变量。 成员变量和关键函数123private final HashMap&lt;BroadcastReceiver, ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt;&gt; mReceivers = new HashMap();private final HashMap&lt;String, ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt;&gt; mActions = new HashMap();private final ArrayList&lt;LocalBroadcastManager.BroadcastRecord&gt; mPendingBroadcasts = new ArrayList(); 想理解这几个变量的作用，需要去看对应的代码。 下面的代码是LocalBroadcastManager#registerReceiver()函数，从代码注释中的 标识1 标识2 可以看出变量名为mReceivers的HashMap存放通过注册的BroadcastReceiver（广播接收者）对象和存放了广播接收者信息的ReceiverRecord。从 标识4 标识5 不难看出变量名为mActions的HashMap存放的是通过LocalBroadcastManager#registerReceiver()方法注册的Action事件和这个事件所对应的所有ReceiverRecord。 1234567891011121314151617181920212223242526272829// 注册BroadcastReceiver（广播接收者）public void registerReceiver(@NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter) &#123; synchronized(this.mReceivers) &#123; LocalBroadcastManager.ReceiverRecord entry = new LocalBroadcastManager.ReceiverRecord(filter, receiver); ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt; filters = (ArrayList)this.mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList(1); /** 标识1：以BroadcastReceiver为键，ReceiverRecord集合为值存放到mReceivers中 */ this.mReceivers.put(receiver, filters); &#125; /** 标识2：将ReceiverRecord存放到ReceiverRecord集合中 */ filters.add(entry); /** 标识3：遍历需要注册的Action集合 */ for(int i = 0; i &lt; filter.countActions(); ++i) &#123; String action = filter.getAction(i); ArrayList&lt;LocalBroadcastManager.ReceiverRecord&gt; entries = (ArrayList)this.mActions.get(action); if (entries == null) &#123; entries = new ArrayList(1); /** 标识4：以Action为键，Action对应的ReceiverRecord集合为值，存放到mActions中 */ this.mActions.put(action, entries); &#125; /** 标识5：将ReceiverRecord存放到Action对应的ReceiverRecord集合中 */ entries.add(entry); &#125; &#125;&#125; 怎么还有个变量没有解释呢？别着急，想知道另一个变量的作用，需要看另一个函数的代码，那就是sendBroadcast函数。从下面的代码注释中，可以看出sendBroadcast函数的作用就是从前面介绍的mActions两个集合中取出需要通知的广播接收者，使用 BroadcastRecord 进行记录，并触发执行executePendingBroadcasts函数罢了。 123456789101112131415// 发送广播函数public boolean sendBroadcast(@NonNull Intent intent) &#123; // 省略代码：标识1 根据Intent中的信息从mActions中 if (receivers != null) &#123; // 省略代码 /** 标识2：将发送的Intent和所有需要接收这个Intent的广播接收者封装为BroadcastRecord，并将其存放到mPendingBroadcasts中*/ this.mPendingBroadcasts.add(new LocalBroadcastManager.BroadcastRecord(intent, receivers)); /** 标识3：发送了一个Handler消息，追踪后发现，最后调用了executePendingBroadcasts函数 */ if (!this.mHandler.hasMessages(1)) &#123; this.mHandler.sendEmptyMessage(1); &#125; return true; &#125; // 省略代码&#125; 而executePendingBroadcasts从函数名和前面的逻辑就可以猜到这个函数肯定是通知广播接收器接收Intent，并执行各自操作的最终函数。研究下面这个函数的代码后发现我们的猜测果然没有错，函数就是通过循环调用广播接收器的回调函数来实现 _广播_ 的功能的。什么本地广播管理器嘛，名头这么大，原来本质上就是通过普通的回调实现的。 1234567891011121314151617181920212223242526272829void executePendingBroadcasts() &#123; // 注意这里是死循环 while(true) &#123; LocalBroadcastManager.BroadcastRecord[] brs; synchronized(this.mReceivers) &#123; int N = this.mPendingBroadcasts.size(); if (N &lt;= 0) &#123; // 当所有的广播接收器都通知到后，跳出死循环 return; &#125; // 取出所有的BroadcastRecord存放到临时列表中，并清空原列表 brs = new LocalBroadcastManager.BroadcastRecord[N]; this.mPendingBroadcasts.toArray(brs); this.mPendingBroadcasts.clear(); &#125; // 循环临时列表调用广播接收者的onReceive函数 for(int i = 0; i &lt; brs.length; ++i) &#123; LocalBroadcastManager.BroadcastRecord br = brs[i]; int nbr = br.receivers.size(); for(int j = 0; j &lt; nbr; ++j) &#123; LocalBroadcastManager.ReceiverRecord rec = (LocalBroadcastManager.ReceiverRecord)br.receivers.get(j); if (!rec.dead) &#123; rec.receiver.onReceive(this.mAppContext, br.intent); &#125; &#125; &#125; &#125;&#125; 总结前面通过分析LocalBroadcastManager的源码，我们对LocalBroadcastManager有了更深的理解。我们发现它并没有很复杂的逻辑实现，但却提供了很有用的功能。同时我们只是分析了它的大致逻辑实现原理，并没有对细节做分析，比如：synchronized关键字的使用，为什么通过Handler来触发执行函数？而executePendingBroadcasts函数中为什么要使用死循环来实现？这些细节就要自己去分析理解了，这样才能提高自己的代码水平。我当然已经想通了，哈哈～ LocalBroadcastManager封装为了方便使用LocalBroadcastManager，我对LocalBroadcastManager进行了简单的封装，不仅有Java语言实现，还有Kotlin语言的实现。顺便说一下，Kotlin真好用！ Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.content.LocalBroadcastManager;/** * @Desc LocalBroadcastManager工具类 * @Author wangwh * @Date 2019-03-14 15:06 */@SuppressWarnings("WeakerAccess")public class LBMUtils &#123; private LBMUtils() &#123; throw new RuntimeException("Do not need instantiate!"); &#125; @NonNull public static LocalBroadcastManager getBroadcastManager(@NonNull Context ctx) &#123; return LocalBroadcastManager.getInstance(ctx); &#125; @Nullable public static IntentFilter getIntentFilter(@NonNull String... actions) &#123; IntentFilter filter = null; if (actions.length &gt; 0) &#123; filter = new IntentFilter(); for (String action : actions) &#123; filter.addAction(action); &#125; &#125; return filter; &#125; /** * @Desc 通过Action注册广播接收者 * @Param [ctx, receiver, actions] */ public static void registerReceiver(@NonNull Context ctx, @NonNull BroadcastReceiver receiver, @NonNull String... actions) &#123; IntentFilter filter = getIntentFilter(actions); if (filter != null) &#123; registerReceiver(ctx, receiver, filter); &#125; &#125; /** * @Desc 通过IntentFilter注册广播接收者 * @Param [ctx, receiver, filter] */ public static void registerReceiver(@NonNull Context ctx, @NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter) &#123; getBroadcastManager(ctx).registerReceiver(receiver, filter); &#125; /** * @Desc 注销广播接收者 * @Param [ctx, receiver] */ public static void unRegisterReceiver(@NonNull Context ctx, BroadcastReceiver receiver) &#123; getBroadcastManager(ctx).unregisterReceiver(receiver); &#125; /** * @Desc 通过Action发送广播 * @Param [ctx, action] */ public static void sendBroadcast(@NonNull Context ctx, @NonNull String action) &#123; sendBroadcast(ctx, new Intent(action)); &#125; /** * @Desc 通过intent发送广播 * @Param [ctx, intent] */ public static void sendBroadcast(@NonNull Context ctx, @NonNull Intent intent) &#123; getBroadcastManager(ctx).sendBroadcast(intent); &#125; /** * @Desc 通过Action同步发送广播 * @Param [ctx, action] */ public static void sendBroadcastSync(@NonNull Context ctx, @NonNull String action) &#123; sendBroadcastSync(ctx, new Intent(action)); &#125; /** * @Desc 通过Intent同步发送广播 * @Param [ctx, intent] */ public static void sendBroadcastSync(@NonNull Context ctx, @NonNull Intent intent) &#123; getBroadcastManager(ctx).sendBroadcastSync(intent); &#125;&#125; Kotlin实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@file:Suppress("NOTHING_TO_INLINE", "unused", "DEPRECATION", "SpellCheckingInspection")import android.app.Fragmentimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Intentimport android.content.IntentFilterimport android.support.v4.app.Fragment as FragmentV4import android.support.v4.content.LocalBroadcastManagerimport android.view.Viewimport org.jetbrains.anko.AnkoContext/** * @Desc LocalBroadcastManager扩展 Kotlin API * @Author wangwh * @Date 2019-03-06 15:46 */fun getIntentFilter(vararg actions: String): IntentFilter &#123; val filter = IntentFilter() for (action in actions) &#123; filter.addAction(action) &#125; return filter&#125;// Context 的扩展实现inline fun Context.unRegisterReceiver(receiver: BroadcastReceiver) = getBroadcastManager().unregisterReceiver(receiver)inline fun Context.getBroadcastManager(): LocalBroadcastManager = LocalBroadcastManager.getInstance(this)inline fun Context.sendBroadcast(action: String) = sendBroadcast(Intent(action))inline fun Context.sendBroadcastSync(intent: Intent) = getBroadcastManager().sendBroadcastSync(intent)// 同上实现，对 AnkoContext 进行扩展inline fun AnkoContext&lt;*&gt;.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = ctx.registerReceiver(receiver, filter)inline fun AnkoContext&lt;*&gt;.unRegisterReceiver(receiver: BroadcastReceiver) = ctx.unRegisterReceiver(receiver)inline fun AnkoContext&lt;*&gt;.sendBroadcast(action: String) = ctx.sendBroadcast(action)inline fun AnkoContext&lt;*&gt;.sendBroadcast(intent: Intent) = ctx.sendBroadcast(intent)inline fun AnkoContext&lt;*&gt;.sendBroadcastSync(action: String) = ctx.sendBroadcast(action)inline fun AnkoContext&lt;*&gt;.sendBroadcastSync(intent: Intent) = ctx.sendBroadcastSync(intent)// 同上实现，对 View 进行扩展inline fun View.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = context.registerReceiver(receiver, filter)inline fun View.unRegisterReceiver(receiver: BroadcastReceiver) = context.unRegisterReceiver(receiver)inline fun View.sendBroadcast(action: String) = context.sendBroadcast(action)inline fun View.sendBroadcast(intent: Intent) = context.sendBroadcast(intent)inline fun View.sendBroadcastSync(action: String) = context.sendBroadcast(action)inline fun View.sendBroadcastSync(intent: Intent) = context.sendBroadcastSync(intent)// 同上实现，对 Fragment 进行扩展inline fun Fragment.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = activity.registerReceiver(receiver, filter)inline fun Fragment.unRegisterReceiver(receiver: BroadcastReceiver) = activity.unRegisterReceiver(receiver)inline fun Fragment.sendBroadcast(action: String) = activity.sendBroadcast(action)inline fun Fragment.sendBroadcast(intent: Intent) = activity.sendBroadcast(intent)inline fun Fragment.sendBroadcastSync(action: String) = activity.sendBroadcast(action)inline fun Fragment.sendBroadcastSync(intent: Intent) = activity.sendBroadcastSync(intent)// 同上实现，对 FragmentV4 进行扩展inline fun FragmentV4.registerReceiver(receiver: BroadcastReceiver, filter: IntentFilter) = requireActivity().registerReceiver(receiver, filter)inline fun FragmentV4.unRegisterReceiver(receiver: BroadcastReceiver) = requireActivity().unRegisterReceiver(receiver)inline fun FragmentV4.sendBroadcast(action: String) = requireActivity().sendBroadcast(action)inline fun FragmentV4.sendBroadcast(intent: Intent) = requireActivity().sendBroadcast(intent)inline fun FragmentV4.sendBroadcastSync(action: String) = requireActivity().sendBroadcast(action)inline fun FragmentV4.sendBroadcastSync(intent: Intent) = requireActivity().sendBroadcastSync(intent)]]></content>
      <categories>
        <category>资料</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>知识点</tag>
        <tag>编程</tag>
        <tag>Broadcast</tag>
        <tag>LocalBroadcastManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava详解]]></title>
    <url>%2Fblog%2FRxJava%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这篇文章大概是2017年时整理的，一直在OneNote中存放着，如今创建了个人博客，自然拿了出来。PS：从OneNote中复制出来后格式乱码，整理的我想吐… 介绍RxJava是Java上一个灵活的、使用可观测序列组成的一个异步的、基于事件的库。 特点： 作用：异步 模式：观察者模式-本质上是基于回调 结构：响应式编程 逻辑简洁，可读性高，易维护 链式结构的执行顺序 基本流程 创建事件资源，也就是被观察者。可以用Observable.create/just/from等方法来创建。 通过filter/debounce等操作符，进行自定义事件过滤。 通过Schedules进行事件发送和订阅的线程控制，也就是subscribeOn()和observeOn()。 通过map/flatMap/compose等操作符，进行事件的变换 调用subscribe进行事件订阅。 最后，不要忘了对订阅者生命周期的控制，不用的时候，记得调用unsubscribe()，以免引发内存泄漏。 注意：未取消订阅而引起的内存泄漏。在Activtity.onDestroy()或不需要继续执行时取消订阅。CompositeSubscription， 相当于一个Subscription集合，来取消所有订阅。 示例123456CompositeSubscription list = new CompositeSubscription();list.add(subscription1);list.add(subscription2);list.add(subscription3);// 统一调用一次unsubscribe，就可以把所有的订阅都取消list.unsubscribe(); 基础知识Observer和Subscriber的关系 Observer是观察者，Subscriber也是观察者。 Subscriber是一个实现了Observer接口的抽象类，对Observer进行了部分扩展，在使用上基本没有区别。 Subscriber多了发送之前调用的onStart()和解除订阅关系的unsubscribe()方法。 在RxJava的subscribe过程中，Observer也总是会先被转换成一个Subscriber再使用。 RxJava开发过程中一般都使用Subscriber。 RxJava的事件订阅回调支持以下三种不完整定义的回调，我们可以根据当前需要，传入对应的Action，RxJava会相应的自动创建Subscriber。 observable.subscribe(onNextAction); observable.subscribe(onNextAction, onErrorAction); observable.subscribe(onNextAction, onErrorAction, onCompleteAction); 响应式编程 Observable发出一系列事件，它是事件的产生者。 Subscriber负责处理事件，它是事件的消费者。 Operator是对Observable发出的事件进行修改和变换 。 注意：若事件从产生到消费不需要其他处理，则可以省略掉中间的Operator，从而流程变为Obsevable -&gt; Subscriber。 Subscriber通常在主线程执行，所以原则上不要去处理太多的事务，而这些复杂的事务处理则交给Operator。 知识点Scheduler线程控制默认情况下，RxJava事件产生和消费均在同一个线程中，例如在主线程中调用，那么事件的产生和消费都在主线程，但RxJava可以自由切换线程。 RxJava线程调度器 Schedulers.io(); I/O操作（读写文件、数据库、网络请求等），与 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 效率比 newThread() 更高。值得注意的是，在 io() 下，不要进行大量的计算，以免产生不必要的线程。 Schedulers.newThread(); 开启新线程操作 Schedulers.immediate(); 默认指定的线程，也就是当前线程 Schedulers.computation(); 计算所使用的调度器。这个计算指的是CPU密集型计算，即不会被I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为CPU核数。值得注意的是不要把I/O操作放在computation()中否则I/O操作的等待时间会浪费CPU。 注意： AndroidSchedulers.mainThread();是RxJava扩展的Android主线程。 通过subscribeOn()和observeOn()这两个方法来进行线程调度。 变换操作符（重点）RxJava可以将发送的事件或事件序列，加工后转换成不用的事件或事件序列。 map操作符 是一对一的变换 返回的是变换后的对象 变换后的对象直接发到Subscriber回调中 flatMap操作符 可以适应一对多的变换 返回的是一个Observable被观察者对象 返回的Observable对象并不是直接发送到Subscriber的回调中，而是重新创建一个Observable对象，并激活这个Observable对象，使之开始发送事件 flatMap变换后产生的每一个Observable对象发送的事件，最终都汇入同一个Observable，进而发送给Subscriber回调 注意： map的返回类型与flatMap返回的Observable事件类型，可以与原来的事件类型一样 可以对一个Observable多次使用map和flatMap flatMap常常被用于嵌套的异步操作，例如：嵌套网络请求 map操作符代码示例12345678910111213141516171819202122232425262728293031323334353637final ImageView ivLogo = (ImageView) findViewById(R.id.ivLogo);Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("https://ss2.baidu.com/-vo3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=4db5130a073b5bb5a1d727fe06d2d523/cf1b9d16fdfaaf51965f931e885494eef11f7ad6.jpg"); &#125;&#125;).map(new Func1&lt;String, Drawable&gt;() &#123; @Override public Drawable call(String url) &#123; try &#123; Drawable drawable = Drawable.createFromStream(new URL(url).openStream(), "src"); return drawable; &#125; catch (IOException e) &#123; &#125; return null; &#125;&#125;)// 指定subscribe()所在的线程，也就是call()方法调用的线程.subscribeOn(Schedulers.io())// 指定Subscriber回调方法所在的线程，也就是onCompleted,onError,onNext回调的线程 .observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;Drawable&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, e.toString()); &#125; @Override public void onNext(Drawable drawable) &#123; if (drawable != null) &#123; ivLogo.setImageDrawable(drawable); &#125; &#125;&#125;); flatMap操作符代码示例1234567891011121314151617181920212223242526final List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;() &#123; &#123; add(new Employee("jackson", mission_list1)); add(new Employee("sunny", mission_list2)); &#125;&#125;;Observable.from(list) .flatMap(new Func1&lt;Employee, Observable&lt;Employee.Mission&gt;&gt;() &#123; @Override public Observable&lt;Employee.Mission&gt; call(Employee employee) &#123; return Observable.from(employee.missions); &#125; &#125;) .subscribe(new Subscriber&lt;Employee.Mission&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Employee.Mission mission) &#123; Log.i(TAG, mission.desc); &#125; &#125;); from操作符接收一个集合作为输入，每次输出一个元素给subscriber 注意：若需要执行耗时操作，即使在from中使用subscribeOn(Schedulers.io())，仍然是在主线程执行，会造成界面卡顿甚至崩溃。 from操作符代码示例12345678// 格式：Observable.from(T[] params)Observable.from(new Integer[]&#123;1, 2, 3, 4, 5&#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number:" + number); &#125; &#125;); just操作符接收一个可变参数作为输入，最终也是生成数组，调用from()，每次输出一个元素给subscriber just操作符代码示例12345678// Observable.just(T... params)，params的个数为1 ~ 10Observable.just(1, 2, 3, 4, 5) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number:" + number); &#125; &#125;); filter操作符条件过滤，用于去除不符合条件的事件 filter操作符代码示例1234567891011121314Observable.from(new Integer[]&#123;1, 2, 3, 4, 5&#125;) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer number) &#123; // 偶数返回true，则表示剔除奇数，留下偶数 return number % 2 == 0; &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number:" + number); &#125; &#125;); take操作符最多保留的事件数 doOnNext操作符在处理下一个事件前要做的事 take和doOnNext操作符代码示例1234567891011121314151617181920212223Observable.from(new Integer[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer number) &#123; // 偶数返回true，则表示剔除奇数 return number % 2 == 0; &#125; &#125;) // 最多保留三个，也就是最后剩三个偶数 .take(3) .doOnNext(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; // 在输出偶数之前输出它的hashCode Log.i(TAG, "hahcode = " + number.hashCode() + ""); &#125; &#125;) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.i(TAG, "number = " + number); &#125; &#125;); 输出结果：1234567&gt; hahcode = 2&gt; number = 2&gt; hahcode = 4&gt; number = 4&gt; hahcode = 6&gt; number = 6&gt; debounce操作符过滤在指定的时间间隔之间的事件，接收一个事件后将在指定时间间隔后开始接收事件 debounce操作符代码示例12345678910111213141516171819202122232425262728293031323334353637383940Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; int i = 0; int[] times = new int[]&#123;100, 1000&#125;; while (true) &#123; i++; if (i &gt;= 100) break; subscriber.onNext(i); try &#123; /** 注意: 当i为奇数时，休眠1000ms，然后才发送i+1，这时i不会被过滤掉。 当i为偶数时，只休眠100ms，便发送i+1，这时i会被过滤掉 */ Thread.sleep(times[i % 2]); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; subscriber.onCompleted(); &#125;&#125;)// 间隔400ms以内的事件将被丢弃.debounce(400, TimeUnit.MILLISECONDS).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, "complete"); &#125; @Override public void onError(Throwable e) &#123; Log.e(TAG, e.toString()); &#125; @Override public void onNext(Integer integer) &#123; Log.i(TAG, "integer = " + integer); &#125;&#125;); merge操作符用于合并两个Observable为一个Observable格式： 12Observable.merge(Observable1, Observable2).subscribe(subscriber); concat操作符顺序的执行多个Ovservable，个数为1—9（示例见first操作符） compose操作符类似flatMap，都是进行变换，返回Observable对象，激活并发送事件 和flatmap区别 compose是唯一一个能从数据流中得到原始Observable的操作符，需要对整个数据流产生作用的操作需使用compose来实现。如subscribeOn()和observeOn()，在flatMap中使用的话，仅对在flatMap中创建的Observable起作用，不会对剩下的流产生影响. compose是对Observable整体的变换。flatMap转换Observable里的每一个事件，compose转换的是整个Observable数据流。 flatMap每发送一个事件都创建一个Observable，效率低。compose只在主干数据流上执行操作。 建议使用compose代替flatMap。 first操作符只发送符合条件的第一个事件。如：可以结合contact做网络三级缓存 first操作符代码示例123456789101112131415161718192021222324252627282930// 从缓存获取Observable&lt;BookList&gt; fromDisk = Observable.create(new Observable.OnSubscribe&lt;BookList&gt;() &#123; @Override public void call(Subscriber&lt;? super BookList&gt; subscriber) &#123; BookList list = getFromDisk(); if (list != null) &#123; subscriber.onNext(list); &#125; else &#123; subscriber.onCompleted(); &#125; &#125;&#125;);// 从网络获取Observable&lt;BookList&gt; fromNetWork = bookApi.getBookDetailDisscussionList();Observable.concat(fromDisk, fromNetWork)// 如果缓存不为null，则不再进行网络请求。.first().subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;BookList&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(BookList discussionList) &#123; &#125;&#125;); timer操作符定时器，可以做定时操作或延迟操作 timer操作符代码示例12345678910111213Observable.timer(2, TimeUnit.SECONDS) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Long aLong) &#123; Log.i(TAG, "Hello World!"); &#125; &#125;); interval操作符定时的周期性操作，与timer操作符的区别是可以重复操作 throttleFirst操作符类似debounce操作符，时间间隔太短就会丢弃事件。可用于防抖操作，如防止双击 throttleFirst操作符代码示例1234567891011121314RxView.clicks(button) .throttleFirst(1, TimeUnit.SECONDS) .subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; Log.i(TAG, "do clicked!"); &#125; &#125;); Single操作符相当于Observable的精简版。观察者回调的不是onNext/onError/onCompleted，而是回调onSuccess/onError subject操作符既是事件的生产者，又是事件的消费者 subject操作符代码示例1234567891011121314151617181920212223242526Subject subject = PublishSubject.create();subject.debounce(400, TimeUnit.MILLISECONDS) .subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Object o) &#123; // request &#125; &#125;);edittext.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; subject.onNext(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125;); 参考资料-&gt;RxJava详解-由浅入深这是当时的文章名称，如今去看作者已经进行了更新RxJava 从入门到出轨，也是骚的不行～]]></content>
      <categories>
        <category>资料</category>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https协议详解]]></title>
    <url>%2Fblog%2FHttps%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文内容主要讲解Https协议，其他网络知识点作为理解Https协议的辅助。 首先，需要简单知道网络协议的四个层次，即：网络接口层，网络层，传输层，应用层。 Http协议Http协议是一种超文本传输协议，是客户端浏览器与服务器之前的 应用层 通信协议。Http协议不提供数据加密，以明文的方式发送内容，容易被攻击截取信息，不适合用于传输一些敏感信息。 Https协议Https协议是以安全为目标的Http通道，在Http的基础上加入SSL层，简单来说就是Http协议的安全版。Https协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 在进行详细解释Https之前，我们需要先简单了解一些Https协议使用到的关键技术。 关键技术对称加密对称加密使用加密和解密使用相同密钥的加密算法进行加密，也叫私钥加密。常见的对称加密有：DES, AES 等。 非对称加密非对称加密与对称加密不同，使用非对称加密算法进行加密，需要两个密钥，即公钥和私钥。公钥和私钥是成对出现的，在加密和解密的过程中使用不同的密钥，所以也称为公钥加密。 数字摘要数字摘要采用单项Hash函数将需要加密的明文 _摘要_ 成一串固定长度（128位）的密文，这个密文又称为数字指纹。不同的明文摘生成的数字指纹总是不同的，而同样的明文摘要生成的数字指纹必定一致。数字摘要 是Https能确保数据完整性和防篡改的根本原因。 数字签名数字签名是对 非对称加密 和 数字摘要 两项技术的应用。它将 摘要信息 用发送者的私钥加密，与原文一起传送给接收者。接收者只有使用发送者的公钥才能解密出被加密的 摘要信息；接着对接收到的原文用 数字摘要 生成 摘要信息；然后将两个 摘要信息 进行对比。若相同，说明收到的原文是完整的，在传输过程中没有被修改。因此，数字签名能够验证数据的完整性。 SSLSSL是安全套接层，用以保障数据传输的安全，利用数据加密技术确保数据在传输过程中不会被截取。 SSL又可分为两层： SSL记录协议建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装，压缩，加密等基本功能的支持。 SSL握手协议建立在SSL记录协议之上，用于在实际的数据开始传输前，通讯双方进行身份认证，协商加密算法，交换加密密钥等。 SSL/TLS握手流程SSL/TLS握手过程流程图： 客户端发起请求：在SSL/TLS协议传输过程中，客户端和服务端必须使用同一套加解密算法才能保证数据正常的加解密。由于客户端对一些加解密算法的支持程度不一样，所以客户端需要告知服务端自己支持的加密套件的列表传给服务端。此外，客户端还要生成一个随机数（第一个随机数），用于传送给服务端，在后面的步骤中与服务端生成的随机数结合起来产生 对话密钥。 那么客户端需要提供的信息： 支持的协议版本 支持的加密算法 支持的压缩方法 随机数 服务端响应：服务端确定加密协议的版本和加密算法后，也生成一个随机数（第二个随机数），并将自己的证书一并发送给客户端。 服务端需要提供的信息： 确定支持的版本 确定加密的算法 随机数 服务器证书，包含公钥 注意：一些场景下，服务器需要确认客户端的身份，会要求客户端提供 客户端证书 客户端验证证书：客户端先对服务器下发的证书进行验证，验证通过后客户端再生成一个随机数（第三个随机数，也是最关键的随机数），并使用证书中的公钥对随机数进行加密，再加入一个 ChangeCipherSpec 即编码改变的消息和前面所有消息的Hash值，最后将所有的这些信息发送到服务器，确保在正式通信前无误。 此时，客户端得到全部的三个随机数，客户端会用协商的加密方法，生成本次会话所用的同一把 会话密钥。 ChangeCipherSpec是一个独立的协议，在数据包中就是一个字节的数据，用于告知服务端：客户端已经切换到了协商好的加密套件，准备好加密数据并进行传输了。 客户端提供的信息： 使用服务器证书中的公钥加密后的随机数（第三个） ChangeCipherSpec 编码改变的通知 握手结束的通知 注意：如果服务端需要客户端证书，客户端会在这一步发送证书信息。 服务端生成秘钥：使用私钥对随机数（第三个）的加密数据进行解密，此时服务端得到全部的三个随机数，同样使用协商的加密方法，生成和客户端使用的同一把 会话密钥。准备好后，服务端也会给客户端一个 ChangeCipherSpec 即编码改变的消息，告知客户端已经切换到了协商好的加密套件，准备好加密数据并进行传输了。 之后，服务端会使用 会话密钥 加密一段finish消息发送给客户端，以验证通过握手建立的加密通道是否成功。 客户端发送数据：确定 会话密钥 后，客户端与服务器之间就会使用对称加密加密数据后传输了。整个握手的过程也就基本完成了。 注意：SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密。因为非对称加密的速度缓慢，比较耗费资源，所以在使用非对称加密建立连接后，客户端和服务器之间传输数据使用的是协商好的对称加密算法和对称加密密钥（即会话密钥）。这个数据传输过程本身是安全可靠的，也就是说对称加密密钥是不可能被窃取盗用的。如果有人窃听通讯，他可以知道双方选择的加密方法，以及三个随机数中的两个，也就是说整个通话的安全，只取决于第三个随机数（客户端生成并加密）能不能被破解。 Session的恢复两种恢复Session对话的方式：Session ID，Session ticket。 Session ID客户端和服务器的每次对话都有一个编号。若对话中断，重连时只要客户端给出编号，并且服务器有该编号的记录，双方就可以使用已有的 对话密钥 重新建立连接，而不用重新走握手流程重新连接。 Session ID是目前所有浏览器都支持的方法，缺点是Session ID往往只保留在一台服务器上，如果客户端重连时请求发到另一台服务器上，就无法恢复对话。 Session ticket客户端发送一个服务器在上次对话中发送过来的Session ticket，其中包括对话的主要信息，如：对话密钥和加密方法等。这个Session ticket是加密的，只有服务器才能解密，服务器在解密Session ticket后就不用重新生成对话密钥了。 目前只有部分浏览器支持，如：Chrome和Firefox 参考资料： 风化成石：Https协议详解 推荐一看，文章主要精华都吸取自该博客。 施小喵：HTTPS原理解析 K__M：https协议原理]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>求职</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点-常见面试题]]></title>
    <url>%2Fblog%2FAndroid%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文用于记录Android面试时经常遇到的问题，答案由我本人研究总结后填充，方便回忆知识点，日后面试前准备，学习交流等目的。 答案会在日后空闲时间慢慢填充 题目目录初始取材：莫少侠：18年底Android面经分享 网络基础Https原理见：Https协议详解 Http与Https的区别？TCP和UDP的区别？Http的报文结构？cookie的用处？Http有哪些响应码，都代表什么意思？ 多线程Sleep和wait的区别？Java有哪些线程池，区别是什么？线程池的工作流程和实现原理Cache线程池的缺点？多线程的通信方式synchronize关键字的用法，其他的同步方式？Thread直接调用run方法会怎么样？Start方法作用是什么？volatile关键字的作用是什么？怎么安全停止一个线程任务？原理是什么？线程池有类似的机制吗？ 数据结构HashMap和HashTable的区别？HashMap和ConcurrentHashMap的区别？HashMap和LinkedHashMap的区别？HashMap的内部实现原理LRUCache的原理ArrayList和LinkedList的区别？为什么ArrayList不是线程安全的？数据库的索引用是什么数据结构？ 虚拟机Java垃圾回收机制？有哪些对象可以作为GC roots？跟Art，Dalvik对比Java内存模型类加载机制？双亲委托模型？ Android题项目中遇到的难题或者坑做过那些性能优化？怎么评测和具体实现的Activity的冷启动流程？AMS的作用？怎么分析内存泄露？View的事件分发机制？滑动冲突如何解决？自定义View的原理和流程Handler原理Android有哪些多线程通信方式？Binder机制实现？Android的生命周期，启动模式项目中使用的开源库？实现原理？OkHttp，RxJava，Retrofit重点 Android的打包流程？apk中有哪些东西？签名算法的原理？了解哪些插件话技术LinearLayout的布局流程MVP，MVVMAndroid怎么做保活？ 算法 排序相关的（快排，分析不同排序区别，时间复杂度等） 字符串、数组相关的（滑动窗口、双指针） 链表（反转链表） 递归、斐波那契数列（爬楼梯） 动态规划 其他用过那些设计模式？DCL单例模式为什么要两次判空？Android源码中或用过的开源库用到了什么设计模式？final关键字的作用？静态内部类和内部类的区别？值传递类问题Kotlin为什么能和Java混编？]]></content>
      <categories>
        <category>资料</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>知识点</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin：作用域函数]]></title>
    <url>%2Fblog%2FKotlin%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言最近使用kotlin语言开发了新的项目，kotlin的一些特性和大量的语法糖相当好用，相比于java，开发效率高了不少。但Kotlin大量的语法糖也带来了一些问题：学习成本高，语法糖使用场景的困惑。比如，当我第一次看到作用域函数就产生了这样的疑问：what is this？Which function to use? 于是我研究了一下什么是作用域函数，以及各个函数的区别和使用场景。 介绍官方介绍：The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions. There are five of them: let, run, with, apply, and also. 翻译理解：作用域函数的目的是在对象的上下文中执行代码块，它为调用者对象提供了一个临时内部作用域，在这个作用域中可以不显式的访问该对象。这样的作用域函数有5个：let，run，with，apply，和also。 函数runrun函数是最能体现作用域的用途的函数，如下使用示例：在mian函数中使用run函数创建了一个单独的作用域，在该作用域中重新定义了一个word变量，两次打印使用的是各自作用域中的word变量，互不影响；并且，run函数返回了lambda结果。 使用示例12345678910fun main(args: Array&lt;String&gt;) &#123; var word = "我是小明" val returnValue = run &#123; var word = "我是小红" println("run:$word") word &#125; println("main:$word") println("returnValue:$returnValue")&#125; 运行结果： 123run:我是小红main:我是小明returnValue:我是小红 withwith函数可以将任意对象作为上下文对象this传入，并且可以隐式的访问该对象，返回lambda结果。如下使用示例：在mian函数中使用with函数创建了一个临时作用域，在该作用域中可以重新定义person变量，两个person变量互无影响；并且可以使用this访问上下文对象，隐式修改person的age变量值。 使用示例12345678910111213141516data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person = Person("小明",25) val returnValue = with(person) &#123; println("with:this=$this") var person = Person("小红",23) println("with:person=$person") age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234with:this=Person(name=小明, age=25)with:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.runT.run函数可以使用T作为作用域的上下文对象this，在作用域中可以隐式访问T对象，并返回lambda结果。 使用示例123456789101112131415161718192021data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null // T?.run当T为null时不调用run函数 person?.run &#123; println("person?.run:person=$person") &#125; person = Person("小明",25) val returnValue = person.run &#123; println("person.run:this=$this") var person = Person("小红",23) println("person.run:person=$person") age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.run:this=Person(name=小明, age=25)person.run:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.letT.let函数与T.run函数唯一的区别是：T作为作用域上下文对象的名称不同，前者是it，后者是this，所以在T.let函数中必须显式使用it访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null person?.let &#123; println("person?.let:person=$person") &#125; person = Person("小明",25) val returnValue = person.let &#123; println("person.let:it=$it") var person = Person("小红",23) println("person.let:person=$person") it.age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.let:it=Person(name=小明, age=25)person.let:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.also如下使用示例，T.also函数和T.let函数的唯一区别是：前者返回值是this（即T），后者返回值是lambda结果。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null person?.also &#123; println("person?.also:person=$person") &#125; person = Person("小明",25) val returnValue = person.also &#123; println("person.also:it=$it") var person = Person("小红",23) println("person.also:person=$person") it.age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.also:it=Person(name=小明, age=25)person.also:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) T.apply如下使用示例，T.apply函数和T.also函数的唯一的区别是：T作为作用域上下文对象的名称不同，前者是this，后者是it，所以在T.apply函数中可以隐式访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) &#123; var person: Person? = null person?.apply &#123; println("person?.apply:person=$person") &#125; person = Person("小明",25) val returnValue = person.apply &#123; println("person.apply:this=$this") var person = Person("小红",23) println("person.apply:person=$person") age = 26 person &#125; println("main:person=$person") println("main:returnValue=$returnValue")&#125; 运行结果： 1234person.apply:this=Person(name=小明, age=25)person.apply:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) 特殊的作用域函数T.takeIf以it作为在作用域上下文对象T的名称，若lambda结果为true，返回this；否则，返回null。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin("1.1")public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? &#123; contract &#123; callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) &#125; return if (predicate(this)) this else null&#125; 使用示例123456789fun main(args: Array&lt;String&gt;) &#123; var count = 0 while (count &lt;= 10) &#123; val returnValue = count.takeIf &#123; count++ % 2 == 0 &#125; println(returnValue) &#125;&#125; 运行结果： 12345678910110null2null4null6null8null10 T.takeUnless以it作为在作用域上下文对象T的名称，若lambda结果为true，返回null；否则，返回this。与taskIf的实现相比，其实就是对lambda结果进行了取反操作。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin("1.1")public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? &#123; contract &#123; callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) &#125; return if (!predicate(this)) this else null&#125; 使用示例123456789fun main(args: Array&lt;String&gt;) &#123; var count = 0 while (count &lt;= 10) &#123; val returnValue = count.takeUnless &#123; count++ % 2 == 0 &#125; println(returnValue) &#125;&#125; 运行结果： 1234567891011null1null3null5null7null9null repeat以当前执行的次数it作为在作用域上下文对象T的名称，执行给定lambda函数指定的次数。从函数源码和使用示例可以看出，执行次数角标是从0开始。 函数源码1234567@kotlin.internal.InlineOnlypublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) &#123; contract &#123; callsInPlace(action) &#125; for (index in 0 until times) &#123; action(index) &#125;&#125; 使用示例12345fun main(args: Array&lt;String&gt;) &#123; repeat(5) &#123; print("$it,") &#125;&#125; 运行结果： 10,1,2,3,4, 总结从上面的函数介绍和实际使用可以看出let，run，with，apply，和also，这些作用域函数的功能之间起着相互补充的作用，单独看某两个函数可能差别不大，但它们结合起来所实现的功能涵盖了绝大部分的使用场景。 总结一下，用于快速判断操作符使用场景，主要使用这几个因素辨别： 调用者： 正常函数：有run，with函数。主要作用是：开辟一个作用域，不受作用域之外上下文影响，with还可以方便地在作用域中访问上下文对象。 扩展函数：可以使用T?.fun()在调用之前做空检查，如：null?.run { println(&quot;Kotlin&quot;) }，作用域内容不会被执行。 上下文对象 this：方便在作用域中直接访问this it：可以更清楚的区分作用域和非作用域中的成员 返回值 上下文对象this：可以作为链式调用。 lambda表达式结果：返回表达式结果，可以将结果结合其他作用域函数，使用更灵活。 12345678910// 示例：使用apply函数进行链式调用class Person &#123; var name = "" var age = 0&#125;fun main(args: Array&lt;String&gt;) &#123; val person = Person().apply &#123; name = "小明" &#125;.apply &#123; age = 25 &#125; println("$&#123;person.name&#125;,$&#123;person.age&#125;")&#125;// 运行结果：小明,25 下面对作用域函数简要区分，可以更方便快速的辨别各函数的作用和使用场景。 作用域函数简要区分： run：返回lambda结果 with：this上下文，返回lambda结果 T.run：支持空检查，this上下文，返回lambda结果 T.let：支持空检查，it上下文，返回lambda结果 T.also：支持空检查，it上下文，返回this（即T，it） T.apply：支持空检查，this上下文，返回this（即T，this） 特殊的作用域函数区分： T.takeIf：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回this；否则返回null T.takeUnless：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回null；否则返回this repeat：执行给定函数 action 指定的次数 times （角标：0-times） 参考资料 官方文档：https://www.kotlincn.net/docs/reference/scope-functions.htmlmedium Elye：https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84CSDN george_zyf：https://blog.csdn.net/android_zyf/article/details/82496983]]></content>
      <categories>
        <category>资料</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>编程</tag>
        <tag>run</tag>
        <tag>with</tag>
        <tag>let</tag>
        <tag>also</tag>
        <tag>apply</tag>
        <tag>takeIf</tag>
        <tag>takeUnless</tag>
        <tag>repeat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins持续集成]]></title>
    <url>%2Fblog%2FJenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[安装Jenkins使用可执行安装文件下载安装Jenkins官网下载对应平台的安装文件 Mac下载的是pkg格式安装包 此种方式安装，会在Mac系统里创建一个名为jenkins用户，Jenkins服务就部署在这个用户下 Widows下载的是zip格式的压缩文件，解压后得到exe格式安装包 使用war安装Jenkins官网选择war文件下载 打开终端，进入war文件所在的目录 执行下面命令：java -jar jenkins.war --httpPort=8080 war包自带jetty服务器，执行命令后会启动服务器，并完成部署。 不推荐该方式安装：安装后会在用户的根路径生成.jenkins隐藏文件，并产生多余的配置文件，需要手动管理，并不便卸载。 Mac下使用Homebrew安装 安装Homebrew 自行官网搜索安装方式 安装，命令行执行：brew install jenkins 卸载，命令行执行：brew uninstall jenkins Homebrew会下载，并自动完成所有依赖，包括java。并创建jenkins命令推荐使用该方式安装，不会在系统中产生垃圾文件和多余的配置文件，生成的所有文件都由Homebrew进行管理，方便卸载。 Jenkins常用命令命令行方式 启动服务：brew services start jenkins 该方式启动jenkins服务，在后台运行，终端关闭无影响。 重启服务：brew services restart jenkins 停止服务：brew services stop jenkins 浏览器地址 重载服务：http://localhost:8080/reload 重启服务：http://localhost:8080/restart 停止服务：http://localhost:8080/exit 配置Jenkins创建用户 安装并启动Jenkins服务后，在浏览器中打开http://localhost:8080/，进入配置jenkins页面。 根据提示，打开~/.jenkins/secrets/initialAdminPassword文件，复制密码并填入，点击继续进入安装插件页面。 建议选择，安装推荐的插件。等待插件安装完成后，Jenkins服务会重启，待重启完成后，会进入创建用户页面。 在创建用户页面，填写用户信息后保存。 安装插件除了首次进入Jenkins时安装的推荐插件，还要安装一些必备插件。 Android自动化构建必备插件 Gradle Plugin Gitlab Plugin]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>软件</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS系统安装必备软件和搭建开发环境]]></title>
    <url>%2Fblog%2FmacOS%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6%E5%92%8C%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[由于个人喜欢折腾系统和软件，一段时间后总觉得系统会残留很多的垃圾文件，每到这时总控制不住自己去清空数据后重装系统。所以做下记录，方便在重装系统后快速恢复工作环境。另外，推荐一些常用软件和平常发现的一些比较好用的软件。 必备软件 ntfs for mac SSR客户端 Chrome 主题：Just Black，Oceanic，Slate，Material Incognito Dark Theme 插件：Axure RP，Adblock Plus，Json Formatter QQ 微信 IINA视频播放器 OneDrive Keka Folx Pdf Expert（Pdf文件阅读编辑） Contexts（窗口切换管理） Quiver（代码库） Swivik for Mac（快捷切换应用） Visual Studio Code及必备插件 Chinese (Simplified) Language Pack for Visual Studio Code Markdown All in One markdownlint（检查markdown语法） Mardwodn PDF（转换为pdf，html，png或jpeg文件） Code Runner vscode-pdf 命令行工具 Homebrew：/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; nano：brew install nano autojump： 第一步：brew install autojump 第二步 git clone https://github.com/wting/autojump.git ./autojump/install.py fish：brew install fish 若安装了autojump，配置fish： touch ~/.config/fish/config.fish 输入下方代码后保存 source ~/.config/fish/config.fish 注意 autojump.fish 文件是通过clone后执行install.py文件生成的 123456begin set --local AUTOJUMP_PATH $HOME/.autojump/share/autojump/autojump.fish if test -e $AUTOJUMP_PATH source $AUTOJUMP_PATH endend 搭建开发环境jdk1.8 下载安装：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 关闭自动更新 配置环境变量：nano ~/.bash_profile 注意jdk版本路径 配置Visual Studio Code的settings.json 12345# Javaexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Homeexport PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/binexport PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/lib/tools.jarexport PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/lib/dt.jar 123&#123; "java.home": "/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home"&#125; Git brew安装：brew install git SSH： 全局设置用户名：git config --global user.name &quot;wangwh&quot; 全局设置邮箱：git config --global user.email &quot;wenhui.wang@gymchina.com&quot; 生成密钥：ssh-keygen -t rsa -C &quot;wenhui.wang@gymchina.com&quot; 密钥保存在：～/.ssh/文件夹中 添加密钥：ssh-add id_ras 若添加密钥出现错误：Could not open a connection to your authentication agent，执行：ssh-agent bash 在git服务器上添加公钥 Android 下载安装ideaIC 配置Android Sdk环境变量 12345# Androidexport ANDROID_HOME=~/Documents/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/tools/bin 安装必备插件 GenerateSerialVersionUID Parcelable Code Generator(for kotlin) JSON To Kotlin Class (JsonToKotlinClass) Anko Support Json Parser Flutter 下载Flutter 将Flutter解压 配置Flutter环境变量 Visual Studio Code插件 Flutter（安装时会依赖安装Dart） Android iOS Emulator 配置sdk路径：Setting - User Setting - Extensions - Emulator：~/Documents/Android/sdk/emulator 命令行检查环境是否配置成功：flutter doctor，然后根据错误提示进行操作 使用ideaIC创建Android模拟器 123456# Flutterexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport FLUTTER_HOME=~/Documents/Flutter/flutterexport PATH=$&#123;PATH&#125;:$&#123;FLUTTER_HOME&#125;/binexport PATH="$PWD/flutter/bin:$PATH"]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>软件</tag>
        <tag>系统</tag>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2Fblog%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这遍笔记最早可以追溯到2015年，已记不清是怎么了解到的Markdown。当时就被Markdown可以直接转换为html的特性震惊了，随后立即学习了一下Markdown的语法，并随手作为练习语法将之记录了下来。不过由于当时使用了印象笔记记录信息，只用Markdown写了几次后，就没有再使用过，现在重新捡了起来，真香～ 标题的使用 最多6级标题 一级标题二级标题三级标题四级标题五级标题六级列表列表无序列表 可以使用 - + * 列表中可以加入其他语法，如：标题 1 2 3 4 5 6 有序列表 1 2 加入其他语法 区块引用 This is a blockquote.inside a list item. 代码区块 行内代码 代码块 使用区块引用 可以只在段落第一行加 &gt; 区块引用可以嵌套 区块引用内可以加入其他语法这是一个标题。 这是第一行列表项。 这是第二行列表项。给出一些例子代码：行内代码 插入链接行内链接 格式：[链接上的文字](http://example.com &quot;标题&quot;) 这是 Google 官网 参考式链接（定义链接内容） 格式：[链接标识]: http://example.com/ &quot;标题&quot; 引用参考式链接：这是 MSN 官网 隐式链接标记功能步骤： 简化参考式链接：bing 等同于 bing 定义链接内容：bing: http://bing.com/ 引用隐式链接：这是bing官网 自动链接 链接文字和链接地址相同 http://example.com/ &#x61;&#100;&#x64;&#114;&#101;&#x73;&#115;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d; 插入图片 强调：粗体和斜体 使用 * 和 _ 两个符号强调字词，单个符号表示斜体，两个相同符号表示粗体 粗体这是一段粗体文字 这是一段粗体文字 斜体这是一段斜体文字 这是一段斜体文字 表格 冒号表示对齐方式 编号 姓名 年龄 001 小泽 21 002 小苍 22 003 小呆 20 代码框的使用方式 行内代码：使用两个 `(反引号) 把中间的代码包裹起来 代码块：使用Tab键 123public void main () &#123; System.out.println("Hello Markdown");&#125; 用多个反引号插入反引号：There is a literal backtick (`) here. 分割线的使用使用3个或以上的 * - 符号建立分割线（中间可以有空格) 反斜杠转义字符：\支持以下字符： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>资料</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github+Coding搭建个人博客]]></title>
    <url>%2Fblog%2FHexo-Github-Coding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[# 前言两年前，我就产生过搭建个人博客的想法，但在了解到搭建博客需要购买服务器，域名，配置博客平台等，发现需要投入的精力太大，之后因为工作繁忙等原因，搭建个人博客的事就不了了之了。 由于近期工作节奏较慢，想梳理和扩展下自己的知识面，同时给自己一个压力，让自己处于积极向上的状态，终于开始了个人博客的搭建。 在网上搜索后，发现有一种方式可以绕过个人服务器搭建博客，减少了一些精力和成本，而且能很好地满足我的个人需求，那就是Hexo+Github+Coding。 Github大家都知道，是目前全球最大的男性同性交友平台。开个玩笑，不在多述。Coding是腾讯开发者代码托管平台，相比Github平台的优点是可以免费创建私人仓库，并提供了pages服务，是我们实现个人博客的基础。 下面主要说下Hexo。 HexoHexo 搭建步骤 获取个人域名 安装Git 安装nodejs 安装Hexo 注册Github，并创建个人仓库 注册Coding，并创建私人仓库 推送网站 更换主题 发布文章 个性化设置 其他 由于我使用的是Mac笔记本，所以下面的搭建步骤只适合Mac环境 个人域名 域名是我网站的入口，常见的有com，cn，net，org等后缀，可以根据自己的喜好选择后缀。推荐购买国内万网的域名，我选择的是site后缀，相对而言非常便宜了，10年179RMB。 安装Git安装NodeJS建议在官网Node下载安装包进行安装，会包含环境变量和npm的安装，安装后检测node和npm是否安装成功 12node -vnpm -v 安装Hexo1npm install hexo-cli -g Setup your blog 12hexo init blogcd blog Start the server 1hexo server Create a new post 1hexo new "Hello Hexo" Generate static files 1hexo generate Github注册Github 新建仓库 Coding注册Coding 新建仓库 推送网站更换主题发布文章个性化设置其他 未完待续，敬请期待]]></content>
      <categories>
        <category>工具</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>Hexo</tag>
        <tag>Next主题</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
